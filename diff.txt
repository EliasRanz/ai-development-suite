diff --git a/.gitignore b/.gitignore
index c317726..b051730 100644
--- a/.gitignore
+++ b/.gitignore
@@ -78,4 +78,5 @@ htmlcov/
 # Other
 *.bak
 *.tmp
-gemini-context.md
\ No newline at end of file
+gemini-context.md
+*.bat
\ No newline at end of file
diff --git a/comfy_launcher/__init__.py b/comfy_launcher/__init__.py
index e69de29..3be7b67 100644
--- a/comfy_launcher/__init__.py
+++ b/comfy_launcher/__init__.py
@@ -0,0 +1,7 @@
+"""
+ComfyUI Launcher Package.
+This __init__.py can be used to expose package-level objects.
+"""
+from .event_system import EventPublisher, AppEventType
+
+event_publisher = EventPublisher()
\ No newline at end of file
diff --git a/comfy_launcher/__main__.py b/comfy_launcher/__main__.py
index d1e8321..aa9bd33 100644
--- a/comfy_launcher/__main__.py
+++ b/comfy_launcher/__main__.py
@@ -5,21 +5,25 @@ import logging
 from typing import TYPE_CHECKING, Optional
 from pathlib import Path # Ensure Path is imported
 
-from .config import settings
-from .logger_setup import setup_launcher_logger, rotate_and_cleanup_logs
+from .config import settings # Assuming settings is still globally available or passed
+from .log_manager import LogManager # Import the new LogManager
 from .gui_manager import GUIManager
+from . import event_publisher, AppEventType # Import the global event publisher
 from .server_manager import ServerManager
 from .tray_manager import TrayManager
 
 # Define logger and other global instances, initialized in main()
 launcher_logger: logging.Logger = None # type: ignore
 gui_manager_instance: Optional[GUIManager] = None
+log_manager_instance: Optional[LogManager] = None # Add LogManager instance
 server_manager_instance: Optional[ServerManager] = None
 tray_manager_instance: Optional[TrayManager] = None
 app_logic_thread_instance: Optional[threading.Thread] = None
 
 # Global event to signal application-wide shutdown
-app_shutdown_event = threading.Event()
+app_shutdown_event = threading.Event() # Main shutdown signal
+_app_logic_completed_event = threading.Event() # For main to wait for app_logic_thread
+_tray_manager_completed_event = threading.Event() # For main to wait for tray_manager_thread
 
 
 if TYPE_CHECKING:
@@ -34,6 +38,35 @@ if TYPE_CHECKING:
 else:
     LoggerType = logging.Logger
 
+# --- Main Thread Event Handlers (defined at module level) ---
+def _handle_main_thread_quit_request():
+    if launcher_logger: # Check if logger is initialized
+        launcher_logger.info("MainThread Handler: APPLICATION_QUIT_REQUESTED received. Ensuring app_shutdown_event is set.")
+    app_shutdown_event.set()
+
+def _handle_critical_error(message: str):
+    if launcher_logger:
+        launcher_logger.critical(f"MainThread Handler: APPLICATION_CRITICAL_ERROR: {message}")
+    if gui_manager_instance: # Check if GUI manager exists to show error
+        gui_manager_instance.load_critical_error_page(message)
+    app_shutdown_event.set() # Always set shutdown event on critical error
+
+def _handle_server_stopped_unexpectedly(pid: int, returncode: int):
+    message = f"ComfyUI server (PID: {pid}) stopped unexpectedly with code {returncode}. Check server.log."
+    if launcher_logger:
+        launcher_logger.error(f"MainThread Handler: SERVER_STOPPED_UNEXPECTEDLY: {message}")
+    if gui_manager_instance and not app_shutdown_event.is_set(): # Avoid changing page if already quitting
+        gui_manager_instance.load_error_page(message) # Use non-critical error page
+    app_shutdown_event.set() # Ensure main shutdown sequence is triggered
+
+def _handle_app_logic_shutdown_complete():
+    if launcher_logger:
+        launcher_logger.info("MainThread Handler: APP_LOGIC_SHUTDOWN_COMPLETE received.")
+    _app_logic_completed_event.set()
+def _handle_tray_manager_shutdown_complete():
+    if launcher_logger:
+        launcher_logger.info("MainThread Handler: TRAY_MANAGER_SHUTDOWN_COMPLETE received.")
+    _tray_manager_completed_event.set()
 
 def custom_excepthook(exc_type, exc_value, exc_traceback):
     global launcher_logger # Use the global logger from this module
@@ -53,29 +86,40 @@ def app_logic_thread_func(
     server_log_path: 'Path', # Use Path directly
     shutdown_event_param: threading.Event # Added shutdown event
 ):
-    app_logger.info("BACKGROUND THREAD: Started.")
+    # Event to signal that GUI content (loading.html) is loaded
+    # This replaces waiting directly on gui_manager.is_window_loaded
+    _gui_initial_content_loaded_event = threading.Event()
+
+    def _handle_gui_content_loaded():
+        app_logger.info("AppLogic Handler: GUI_WINDOW_CONTENT_LOADED received.")
+        _gui_initial_content_loaded_event.set()
+
+    event_publisher.subscribe(AppEventType.GUI_WINDOW_CONTENT_LOADED, _handle_gui_content_loaded)
+    # No explicit subscription to APPLICATION_QUIT_REQUESTED here, as this thread
+    # primarily relies on the shutdown_event_param (global app_shutdown_event)
+    # which will be set by TrayManager when it publishes the event.
+
+    app_logger.info("Started.")
     server_process = None
     redirect_thread = None
     redirect_thread_stop_event = threading.Event()
 
     try:
-        app_logger.info("BACKGROUND THREAD: Waiting for GUI window to finish loading content...")
-        if not gui_manager.is_window_loaded.wait(timeout=20):
-            app_logger.error("BACKGROUND THREAD: GUI window did not signal 'loaded' in time. Aborting app logic.")
-            if not shutdown_event_param.is_set():
-                gui_manager.load_critical_error_page("GUI did not load correctly. Check launcher logs.")
-            shutdown_event_param.set()
+        app_logger.info("Waiting for GUI window to finish loading initial content (via event)...")
+        if not _gui_initial_content_loaded_event.wait(timeout=20):
+            app_logger.error("GUI window did not signal 'loaded' in time. Aborting app logic.")
+            event_publisher.publish(AppEventType.APPLICATION_CRITICAL_ERROR, message="GUI did not load correctly. Check launcher logs.")
             return
         if shutdown_event_param.is_set(): return
 
-        app_logger.info("BACKGROUND THREAD: GUI content loaded. Proceeding with server launch sequence.")
+        app_logger.info("GUI content loaded. Proceeding with server launch sequence.")
         gui_manager.set_status("Initializing...")
         if shutdown_event_param.wait(0.5): return
 
         if shutdown_event_param.is_set(): return
         gui_manager.set_status(f"Clearing network port {settings.PORT}...")
         if not current_server_manager.kill_process_on_port():
-            app_logger.warning(f"BACKGROUND THREAD: Failed to kill process on port {settings.PORT}. Server start might fail if port is busy.")
+            app_logger.warning(f"Failed to kill process on port {settings.PORT}. Server start might fail if port is busy.")
         if shutdown_event_param.wait(0.5): return
 
         if shutdown_event_param.is_set(): return
@@ -83,14 +127,13 @@ def app_logic_thread_func(
         server_process = current_server_manager.start_server(server_log_path)
 
         if not server_process:
-            app_logger.error("BACKGROUND THREAD: Failed to start ComfyUI server process. Aborting app logic.")
-            if not shutdown_event_param.is_set():
-                gui_manager.load_error_page("Could not start the ComfyUI server. Please check the server.log file for details.")
-            shutdown_event_param.set()
+            app_logger.error("Failed to start ComfyUI server process. Aborting app logic.")
+            # Publishing an error event might be more appropriate here if other components need to react
+            event_publisher.publish(AppEventType.APPLICATION_CRITICAL_ERROR, message="Could not start the ComfyUI server. Please check the server.log file for details.")
             return
         if shutdown_event_param.is_set(): return
 
-        app_logger.info(f"BACKGROUND THREAD: ComfyUI server process started with PID: {server_process.pid}.")
+        app_logger.info(f"ComfyUI server process started with PID: {server_process.pid}.")
 
         redirect_thread = threading.Thread(
             target=gui_manager.redirect_when_ready_loop,
@@ -98,46 +141,67 @@ def app_logic_thread_func(
             daemon=True
         )
         redirect_thread.start()
-        app_logger.info("BACKGROUND THREAD: Redirection loop initiated.")
+        app_logger.info("Redirection loop initiated.")
 
-        app_logger.info("BACKGROUND THREAD: Now monitoring server process and shutdown event.")
+        app_logger.info("Now monitoring server process and shutdown event.")
         while not shutdown_event_param.is_set():
             if server_process.poll() is not None:
-                app_logger.info(f"BACKGROUND THREAD: ComfyUI server process (PID: {server_process.pid}) has exited with code {server_process.returncode}.")
-                if not shutdown_event_param.is_set():
-                    gui_manager.load_error_page(f"ComfyUI server (PID: {server_process.pid}) stopped unexpectedly. Check server.log.")
-                shutdown_event_param.set()
+                app_logger.info(f"ComfyUI server process (PID: {server_process.pid}) has exited with code {server_process.returncode}.")
+                # Publish an event indicating unexpected server stop
+                if not shutdown_event_param.is_set(): # Only publish if not already shutting down
+                    event_publisher.publish(AppEventType.SERVER_STOPPED_UNEXPECTEDLY, pid=server_process.pid, returncode=server_process.returncode)
+                    shutdown_event_param.set() # Also trigger local shutdown for this thread
                 break
             if shutdown_event_param.wait(timeout=1):
                 break
 
     except Exception as e:
-        app_logger.error(f"BACKGROUND THREAD: An error occurred: {e}", exc_info=True)
+        app_logger.error(f"An error occurred: {e}", exc_info=True)
         if not shutdown_event_param.is_set():
-            gui_manager.load_critical_error_page(f"An unexpected error occurred in the background process: {str(e)}")
-        shutdown_event_param.set()
+            event_publisher.publish(AppEventType.APPLICATION_CRITICAL_ERROR, message=f"An unexpected error occurred in the background process: {str(e)}")
     finally:
-        app_logger.info("BACKGROUND THREAD: Cleaning up...")
+        app_logger.info("Cleaning up...")
         redirect_thread_stop_event.set()
 
         if redirect_thread and redirect_thread.is_alive():
-            app_logger.info("BACKGROUND THREAD: Waiting for redirect thread to join...")
+            app_logger.info("Waiting for redirect thread to join...")
             redirect_thread.join(timeout=3)
 
         if current_server_manager and server_process and server_process.poll() is None:
-            app_logger.info("BACKGROUND THREAD: Shutting down ComfyUI server...")
+            app_logger.info("Shutting down ComfyUI server...")
             current_server_manager.shutdown_server()
-        app_logger.info("BACKGROUND THREAD: Finished.")
+        
+        # Unsubscribe handlers to prevent issues if this function were somehow called again
+        event_publisher.unsubscribe(AppEventType.GUI_WINDOW_CONTENT_LOADED, _handle_gui_content_loaded)
+        event_publisher.publish(AppEventType.APP_LOGIC_SHUTDOWN_COMPLETE)
+        app_logger.info("Finished.")
 
 
 def main():
-    global launcher_logger, server_manager_instance, tray_manager_instance, gui_manager_instance
+    global launcher_logger, server_manager_instance, tray_manager_instance, gui_manager_instance, log_manager_instance
     global app_logic_thread_instance, app_shutdown_event
 
-    rotate_and_cleanup_logs(settings.LOG_DIR, settings.MAX_LOG_FILES, settings.MAX_LOG_AGE_DAYS)
-    launcher_logger = setup_launcher_logger(settings.LOG_DIR, settings.DEBUG)
+    # Ensure module-level events are clear at the start of main,
+    # in case of re-entry (e.g., during tests or if main could be called multiple times).
+    app_shutdown_event.clear()
+    _app_logic_completed_event.clear()
+    _tray_manager_completed_event.clear()
+
+    # Initialize LogManager first
+    log_manager_instance = LogManager(
+        log_dir=settings.LOG_DIR, debug_mode=settings.DEBUG,
+        max_files_to_keep_in_archive=settings.MAX_LOG_FILES, max_log_age_days=settings.MAX_LOG_AGE_DAYS
+    )
+    launcher_logger = log_manager_instance.get_launcher_logger() # Get the configured logger
     sys.excepthook = custom_excepthook
 
+    # Subscribe main thread handlers
+    event_publisher.subscribe(AppEventType.APPLICATION_QUIT_REQUESTED, _handle_main_thread_quit_request)
+    event_publisher.subscribe(AppEventType.APPLICATION_CRITICAL_ERROR, _handle_critical_error)
+    event_publisher.subscribe(AppEventType.SERVER_STOPPED_UNEXPECTEDLY, _handle_server_stopped_unexpectedly)
+    event_publisher.subscribe(AppEventType.APP_LOGIC_SHUTDOWN_COMPLETE, _handle_app_logic_shutdown_complete)
+    event_publisher.subscribe(AppEventType.TRAY_MANAGER_SHUTDOWN_COMPLETE, _handle_tray_manager_shutdown_complete)
+
     launcher_logger.info(f"Starting {settings.APP_NAME} (Version 1.0)")
     if settings.DEBUG:
         launcher_logger.debug("Debug mode is ON.")
@@ -185,61 +249,86 @@ def main():
             daemon=True # Daemon so it exits if main thread exits unexpectedly
         )
         app_logic_thread_instance.start()
-        launcher_logger.info(f"MAIN THREAD: {settings.APP_NAME} setup complete. GUI, Tray, and Background thread launched.")
+        launcher_logger.info(f"{settings.APP_NAME} setup complete. GUI, Tray, and Background thread launched.")
 
+        launcher_logger.info("Entering blocking call gui_manager_instance.start_webview_blocking()...")
         # This call is blocking. It will return when webview.destroy_window() is called
         # or if the window is closed and _on_closing doesn't prevent it (which it now does).
         gui_manager_instance.start_webview_blocking()
+        launcher_logger.info("Returned from gui_manager_instance.start_webview_blocking().")
 
         # If start_webview_blocking returns, it means the window was either closed by user
         # (and our _on_closing hid it), or webview.destroy_window() was called.
         # The application should now wait for the app_shutdown_event to be set (e.g., by the tray's Quit).
-        launcher_logger.info("MAIN THREAD: Webview blocking call has returned. Waiting for application shutdown signal.")
-        app_shutdown_event.wait() # Wait for tray "Quit" or other shutdown signal
-        launcher_logger.info("MAIN THREAD: Application shutdown signal received.")
+        launcher_logger.info("Webview blocking call has returned. Waiting for application shutdown signal.")
+        app_shutdown_event.wait() # Wait indefinitely; quit is now signaled by event handlers setting this
+        launcher_logger.info("Application shutdown signal received.")
 
     except Exception as e:
-        launcher_logger.critical(f"MAIN THREAD: An unhandled exception occurred: {e}", exc_info=True)
+        launcher_logger.critical(f"An unhandled exception occurred: {e}", exc_info=True)
         app_shutdown_event.set() # Ensure shutdown is signaled
     finally:
-        launcher_logger.info("MAIN THREAD: Initiating shutdown sequence...")
-        app_shutdown_event.set() # Ensure event is set for all components
-
-        if app_logic_thread_instance and app_logic_thread_instance.is_alive():
-            launcher_logger.info("MAIN THREAD: Waiting for app logic thread to complete...")
-            app_logic_thread_instance.join(timeout=10)
-            if app_logic_thread_instance.is_alive():
-                launcher_logger.warning("MAIN THREAD: App logic thread did not exit cleanly after 10s.")
+        launcher_logger.info("Initiating shutdown sequence (finally block)...")
+        # Ensure app_shutdown_event is set, though it should be by now if quit was graceful.
+        # If an exception occurred before APPLICATION_QUIT_REQUESTED was handled, this ensures it's set.
+        if not app_shutdown_event.is_set():
+            app_shutdown_event.set()
+
+        launcher_logger.info("Checking app logic thread...")
+        if not _app_logic_completed_event.wait(timeout=12): # Increased timeout slightly
+            launcher_logger.info("Waiting for app logic thread to complete...")
+            if app_logic_thread_instance and app_logic_thread_instance.is_alive(): # Check if thread object exists and is alive
+                launcher_logger.warning("App logic thread did not signal completion and is still alive.")
+            elif not app_logic_thread_instance:
+                 launcher_logger.warning("App logic thread instance is None, cannot confirm completion status.")
+        else:
+            launcher_logger.info("App logic thread signaled completion or timed out.")
 
         # Server shutdown is primarily handled by app_logic_thread_func.
         # Final check here.
+        launcher_logger.info("Checking server manager for final shutdown...")
         if server_manager_instance and getattr(server_manager_instance, 'server_process', None) and \
            server_manager_instance.server_process.poll() is None:
-            launcher_logger.info("MAIN THREAD: Performing final check/attempt to shut down ComfyUI server...")
+            launcher_logger.info("Performing final check/attempt to shut down ComfyUI server...")
             server_manager_instance.shutdown_server()
-
-        if tray_manager_instance:
-            launcher_logger.info("MAIN THREAD: Stopping tray manager...")
-            tray_manager_instance.stop()
-
+        else:
+            launcher_logger.info("Server manager or server process not active for final shutdown.")
+
+        # TrayManager's icon.stop() is handled by its own APPLICATION_QUIT_REQUESTED handler.
+        # We wait for the TRAY_MANAGER_SHUTDOWN_COMPLETE event which is published when its run() loop finishes.
+        launcher_logger.info("Checking TrayManager thread...")
+        if not _tray_manager_completed_event.wait(timeout=5):
+            launcher_logger.info("Waiting for TrayManager thread to complete...")
+            if tray_manager_instance and tray_manager_instance._thread and tray_manager_instance._thread.is_alive():
+                launcher_logger.warning("TrayManager thread did not signal completion and is still alive.")
+        else:
+            launcher_logger.info("TrayManager thread signaled completion or timed out.")
+        launcher_logger.info("Checking GUI manager for window destroy...")
         if gui_manager_instance and gui_manager_instance.webview_window:
-            launcher_logger.info("MAIN THREAD: Destroying GUI window...")
+            launcher_logger.info("Destroying GUI window (final step)...")
             # Call destroy() directly on the window instance
-            gui_manager_instance.webview_window.destroy()
-
-        launcher_logger.info(f"MAIN THREAD: {settings.APP_NAME} has exited cleanly.")
+            # This might be redundant if TrayManager already destroyed it, but should be safe.
+            try:
+                gui_manager_instance.webview_window.destroy()
+                launcher_logger.info("MAIN THREAD: GUI window destroy command sent (final step).")
+            except Exception as e: # pywebview might raise if already destroyed or other issues
+                launcher_logger.warning(f"MAIN THREAD: Error destroying GUI window (final step, might be already destroyed): {e}")
+        else:
+            launcher_logger.info("GUI manager or webview window not active for destroy.")
+
+        # Unsubscribe main thread handlers
+        event_publisher.unsubscribe(AppEventType.APPLICATION_QUIT_REQUESTED, _handle_main_thread_quit_request)
+        event_publisher.unsubscribe(AppEventType.APPLICATION_CRITICAL_ERROR, _handle_critical_error)
+        event_publisher.unsubscribe(AppEventType.SERVER_STOPPED_UNEXPECTEDLY, _handle_server_stopped_unexpectedly)
+        event_publisher.unsubscribe(AppEventType.APP_LOGIC_SHUTDOWN_COMPLETE, _handle_app_logic_shutdown_complete)
+        event_publisher.unsubscribe(AppEventType.TRAY_MANAGER_SHUTDOWN_COMPLETE, _handle_tray_manager_shutdown_complete)
+
+        launcher_logger.info(f"{settings.APP_NAME} has exited cleanly.")
         logging.shutdown() # Ensure all log handlers are flushed
 
 
 if __name__ == "__main__":
-    main_logger_pre = logging.getLogger("ComfyUILauncher_PreMain") # Renamed to avoid conflict
-    if not main_logger_pre.hasHandlers():
-        pre_main_handler = logging.StreamHandler(sys.stdout)
-        pre_main_formatter = logging.Formatter("[%(asctime)s] [PRE-MAIN] %(message)s", datefmt="%H:%M:%S")
-        pre_main_handler.setFormatter(pre_main_formatter)
-        main_logger_pre.addHandler(pre_main_handler)
-        main_logger_pre.setLevel(logging.INFO)
-
+    # The main launcher_logger is set up early in main() now, handling console output.
     try:
         main()
     except Exception as e:
diff --git a/comfy_launcher/gui_manager.py b/comfy_launcher/gui_manager.py
index 133112f..5290927 100644
--- a/comfy_launcher/gui_manager.py
+++ b/comfy_launcher/gui_manager.py
@@ -8,13 +8,19 @@ import subprocess
 from typing import Literal, Optional # Added Optional
 
 if platform.system() == "Windows":
-    import winreg
+    try: import winreg
+    except ImportError: winreg = None # Handle cases where winreg might not be available even on Windows
 else:
     winreg = None
 
 from .config import settings
+from . import event_publisher, AppEventType # Import the global event publisher and event types
 
 class GUIManager:
+    # --- Constants for redirect loop ---
+    REDIRECT_LOOP_MAX_WAIT_TIME = 120  # seconds
+    REDIRECT_LOOP_CHECK_INTERVAL = 2  # seconds
+
     def __init__(self, app_name: str, window_width: int, window_height: int,
                  connect_host: str, port: int, assets_dir: Path, logger, server_manager):
         self.app_name = app_name
@@ -29,21 +35,45 @@ class GUIManager:
         self._loading_html_path: Optional[Path] = None
         self.is_window_loaded = threading.Event()
         self.is_window_shown = threading.Event() # Retained, might be useful
+        self.application_is_quitting = False # Flag to indicate if app is quitting
         self.initial_load_done = False # To track if the very first load_html is done
 
-    def _on_closing(self) -> bool:
+        # Subscribe to events
+        event_publisher.subscribe(AppEventType.APPLICATION_QUIT_REQUESTED, self.handle_application_quit_request)
+        event_publisher.subscribe(AppEventType.APPLICATION_CRITICAL_ERROR, self.handle_critical_error_event)
+        event_publisher.subscribe(AppEventType.SERVER_STOPPED_UNEXPECTEDLY, self.handle_server_stopped_unexpectedly_event)
+        event_publisher.subscribe(AppEventType.SHOW_WINDOW_REQUEST, self.handle_show_window_request)
+
+
+    def _on_closing(self, event=None) -> bool: # Added event parameter
         """
         Handles the window close event (e.g., user clicking 'X').
         Instead of quitting, it hides the window. The application continues
         running via the system tray.
-        Return True to prevent the default window close behavior.
+        Return True to prevent the default window close behavior, allowing
+        the event system to handle the actual shutdown and window destruction.
         """
-        self.logger.info("GUI Manager: Window close requested by user.")
+        if event and hasattr(event, 'cancel'): # pywebview might pass an event object
+            event.cancel = True # Prevent immediate closing if pywebview supports it this way
+
+        self.logger.info("Window close event received (_on_closing). Publishing APPLICATION_QUIT_REQUESTED.")
+        
+        # Ensure the application knows it's quitting.
+        # This flag is also set by handle_application_quit_request, but setting it here
+        # ensures that if _on_closing is somehow called before the event is processed,
+        # the state is correct.
+        self.application_is_quitting = True
+        
+        event_publisher.publish(AppEventType.APPLICATION_QUIT_REQUESTED)
+        
+        # Hide the window as per the original intent of the test for _on_closing
         if self.webview_window:
             self.webview_window.hide()
-            self.logger.info("GUI Manager: Window hidden. Application continues in tray.")
-        return True # Prevent default webview close behavior
-
+        
+        # Return True to prevent pywebview from closing the window immediately.
+        # The actual window destruction will be handled by `handle_application_quit_request`
+        # which is subscribed to the APPLICATION_QUIT_REQUESTED event.
+        return True
     def on_loaded(self): # Renamed from _on_loaded to match event subscription
         self.logger.info("🎉 Webview 'on_loaded' event fired!")
         current_url = self.webview_window.get_current_url() if self.webview_window else "N/A"
@@ -51,7 +81,8 @@ class GUIManager:
 
         if not self.initial_load_done:
             # This is the first load (e.g. loading.html)
-            self.logger.debug("Signaling that initial window content is loaded.")
+            self.logger.debug("Initial window content loaded. Publishing GUI_WINDOW_CONTENT_LOADED event.")
+            event_publisher.publish(AppEventType.GUI_WINDOW_CONTENT_LOADED)
             self.is_window_loaded.set()
             self.initial_load_done = True
         else:
@@ -65,6 +96,7 @@ class GUIManager:
 
     def on_shown(self): # Renamed from _on_shown
         self.logger.debug("Webview 'shown' event fired. Window is visible on screen.")
+        event_publisher.publish(AppEventType.GUI_WINDOW_SHOWN)
         if not self.is_window_shown.is_set():
           self.is_window_shown.set()
 
@@ -110,7 +142,15 @@ class GUIManager:
             with open(asset_path, "r", encoding="utf-8") as f: return f.read()
         except FileNotFoundError:
             self.logger.error(f"Asset file not found: {asset_path}")
-            return f"/* Critical asset {relative_path} is missing. */" if is_critical_fallback else ""
+            if is_critical_fallback:
+                # Return a more user-friendly HTML fallback for critical assets
+                self.logger.critical(f"Critical asset '{relative_path}' not found, and no fallback content available other than the hardcoded one.")
+                return """<!DOCTYPE html><html><head><title>Error</title><style>body{font-family:sans-serif;text-align:center;padding:40px;background-color:#333;color:#fff;}h1{color:red;}</style></head>
+                        <body><h1>Critical Error</h1>
+                        <p>If you're seeing this, the application encountered a severe issue and could not load a required file.</p>
+                        <p>Please check the launcher logs for more details.</p>
+                        </body></html>"""
+            return ""
         except Exception as e:
             self.logger.exception(f"Error reading asset file {asset_path}: {e}")
             return ""
@@ -138,7 +178,12 @@ class GUIManager:
 
     def _execute_js(self, js_code: str):
         if self.webview_window:
-            self.webview_window.evaluate_js(js_code)
+            try:
+                self.webview_window.evaluate_js(js_code)
+            except Exception as e:
+                self.logger.error(f"Error executing JavaScript in webview: {e}", exc_info=True)
+        else:
+            self.logger.debug("Cannot execute JS, webview_window is None.")
 
     def set_status(self, message: str):
         self.logger.info(f"[GUI STATUS] {message}")
@@ -146,7 +191,7 @@ class GUIManager:
         self._execute_js(f"if(typeof window.updateStatus === 'function') window.updateStatus('{escaped_message}');")
 
     def py_toggle_devtools(self):
-        if self.webview_window:
+        if self.webview_window: # pragma: no branch
             if settings.DEBUG: self.webview_window.toggle_devtools()
             else: self.logger.info("Developer Tools are disabled (DEBUG mode is off).")
 
@@ -157,7 +202,8 @@ class GUIManager:
             self.logger.info("🪟 Creating GUI window by loading HTML content directly...")
             self.webview_window = webview.create_window(
                 self.app_name, html=html_content, width=self.window_width,
-                height=self.window_height, resizable=True
+                height=self.window_height, resizable=True,
+                confirm_close=False # Avoid pywebview's own confirm dialog; we handle hide/close in _on_closing
             )
             self.webview_window.events.loaded += self.on_loaded
             self.webview_window.events.shown += self.on_shown
@@ -168,12 +214,31 @@ class GUIManager:
                 except Exception as e: self.logger.error(f"Failed to expose py_toggle_devtools: {e}")
             self.logger.info("✅ Window created. Events subscribed & functions exposed.")
         except Exception as e:
-            self.logger.critical(f"GUI Manager: CRITICAL - Failed to create or launch window: {e}", exc_info=True)
+            self.logger.critical(f"CRITICAL - Failed to create or launch window: {e}", exc_info=True)
             if shutdown_event_for_critical_error:
                 shutdown_event_for_critical_error.set()
             # Re-raise or handle as appropriate, for now, it will propagate up if not caught by main
             raise
 
+    def handle_application_quit_request(self):
+        """
+        Handler for the APPLICATION_QUIT_REQUESTED event.
+        Sets the quitting flag and attempts to close the window programmatically to trigger its destruction.
+        """
+        self.logger.info("GUIManager Handler: APPLICATION_QUIT_REQUESTED received. Proceeding with window destruction.")
+        self.application_is_quitting = True
+        
+        window_to_destroy = self.webview_window
+        if window_to_destroy:
+            try:
+                self.logger.debug(f"Destroying window: {window_to_destroy}")
+                self.webview_window = None # Nullify before destroying
+                window_to_destroy.destroy() # Call destroy() on the window instance
+                self.logger.info("Webview window destroyed by handle_application_quit_request.")
+            except Exception as e:
+                self.logger.error(f"Error destroying window in handle_application_quit_request: {e}", exc_info=True)
+        # No need to call window.close() JS anymore, as this handler now directly destroys.
+
     def load_error_page(self, message: str):
         self.logger.error(f"Loading error page with message: {message}")
         error_html_content = self._get_asset_content("error.html")
@@ -211,49 +276,76 @@ class GUIManager:
 
     def redirect_when_ready_loop(self, stop_event: threading.Event,
                                  overall_shutdown_event: threading.Event):
-        self.logger.info("Redirect Loop: Started.")
-        max_wait_time = 120
-        check_interval = 2
+        self.logger.info("Redirect loop: Started.")
         start_time = time.time()
 
         while not stop_event.is_set() and not overall_shutdown_event.is_set():
-            if time.time() - start_time > max_wait_time:
-                self.logger.warning("Redirect Loop: Max wait time exceeded for server availability.")
+            if time.time() - start_time > self.REDIRECT_LOOP_MAX_WAIT_TIME:
+                self.logger.warning("Redirect loop: Max wait time exceeded for server availability.")
                 if not overall_shutdown_event.is_set(): # Avoid changing page if already shutting down
                     self.load_error_page("ComfyUI server did not become available in time. Please check server logs.")
                 break
 
             # Call wait_for_server_availability without the timeout argument
-            if self.server_manager.wait_for_server_availability():
+            if self.server_manager.wait_for_server_availability(retries=1, delay=0.1): # Use small retry/delay for quick check
                 target_url = f"http://{self.connect_host}:{self.port}"
-                self.logger.info(f"Redirect Loop: Server is available. Redirecting webview to {target_url}")
+                self.logger.info(f"Redirect loop: Server is available. Attempting to redirect webview to {target_url}")
                 if self.webview_window:
                     self._execute_js("if(typeof window.fadeOutLoading === 'function') window.fadeOutLoading();")
                     time.sleep(1.5) # Give fade out animation time
                     if not overall_shutdown_event.is_set(): # Check again before loading URL
                         self.webview_window.load_url(target_url)
                 else:
-                    self.logger.error("Redirect Loop: Webview window is not available for redirection.")
+                    self.logger.error("Redirect loop: Webview window is not available for redirection.")
+                self.set_status("Connected to ComfyUI.") # Set status on successful connection
                 break
             else:
                 # Update log message to reflect the actual retry interval
-                self.logger.debug(f"Redirect Loop: Server not yet available. Retrying in {check_interval}s...")
+                self.logger.debug(f"Redirect loop: Server not yet available. Retrying in {self.REDIRECT_LOOP_CHECK_INTERVAL}s...")
 
             if not self.webview_window or getattr(self.webview_window, 'gui', None) is None:
-                self.logger.info("Redirect Loop: Webview window no longer exists. Stopping.")
+                self.logger.info("Redirect loop: Webview window no longer exists. Stopping.")
                 break
             # Wait for 'check_interval', breaking if stop_event is set.
             # The main while loop condition handles overall_shutdown_event.
-            if stop_event.wait(check_interval):
-                self.logger.info("Redirect Loop: stop_event set during wait. Exiting loop.")
+            if stop_event.wait(self.REDIRECT_LOOP_CHECK_INTERVAL):
+                self.logger.info("Redirect loop: stop_event set during wait. Exiting loop.")
                 break
-        self.logger.info("Redirect Loop: Exiting.")
+        self.logger.info("Redirect loop: Exiting.")
 
 
     def start_webview_blocking(self):
         if self.webview_window:
             self.logger.debug("Starting webview event loop (blocking)...")
-            webview.start(debug=settings.DEBUG, private_mode=False, http_server=True)
+            webview.start(debug=settings.DEBUG, private_mode=False, http_server=False) # Diagnostic change
             self.logger.debug("Webview event loop finished.")
         else:
             self.logger.error("Cannot start webview: window was not created.")
+
+    # --- Event Handlers ---
+    def handle_critical_error_event(self, message: str):
+        self.logger.info(f"Event Handler: Received APPLICATION_CRITICAL_ERROR: {message}")
+        self.load_critical_error_page(message)
+
+    def handle_server_stopped_unexpectedly_event(self, pid: int, returncode: int):
+        # Import app_shutdown_event locally to avoid circular dependency at module level if __main__ imports GUIManager
+        from comfy_launcher.__main__ import app_shutdown_event as global_app_shutdown_event
+        if global_app_shutdown_event.is_set():
+            self.logger.info(f"Event Handler: Received SERVER_STOPPED_UNEXPECTEDLY (PID: {pid}, Code: {returncode}), but app is already shutting down. No error page displayed.")
+            return
+        
+        self.logger.error(f"Event Handler: Received SERVER_STOPPED_UNEXPECTEDLY (PID: {pid}, Code: {returncode}). Displaying error page.")
+        error_message = f"ComfyUI server (PID: {pid}) stopped unexpectedly with code {returncode}. Check server.log."
+        self.load_error_page(error_message)
+
+    def handle_show_window_request(self):
+        self.logger.info("Event Handler: Received SHOW_WINDOW_REQUEST. Attempting to show and activate GUI window.")
+        if self.webview_window:
+            self.webview_window.show()
+            if hasattr(self.webview_window, 'activate'): # Some platforms might not have activate
+                self.webview_window.activate()
+            # Publishing SHOW_WINDOW_REQUEST_RELAYED_TO_GUI is not strictly necessary if this is the final handler
+            # but can be useful for logging or if other components need to know.
+            # event_publisher.publish(AppEventType.SHOW_WINDOW_REQUEST_RELAYED_TO_GUI)
+        else:
+            self.logger.warning("Event Handler: Received SHOW_WINDOW_REQUEST, but webview_window is None. Cannot show.")
diff --git a/comfy_launcher/logger_setup.py b/comfy_launcher/logger_setup.py
deleted file mode 100644
index 0d4bf48..0000000
--- a/comfy_launcher/logger_setup.py
+++ /dev/null
@@ -1,130 +0,0 @@
-import logging
-import logging.handlers
-from pathlib import Path
-from datetime import datetime, timedelta
-import sys
-import os
-
-# --- Launcher's Own Logger ---
-
-def setup_launcher_logger(log_dir: Path, debug_mode: bool) -> logging.Logger:
-    """Configures and returns the logger for the launcher application itself."""
-    log_dir.mkdir(parents=True, exist_ok=True)
-    logger = logging.getLogger("ComfyUILauncher") 
-    logger.setLevel(logging.DEBUG if debug_mode else logging.INFO)
-
-    if logger.hasHandlers():
-        for handler in logger.handlers[:]: 
-            handler.close()
-            logger.removeHandler(handler)
-
-    # Only add console handler if in debug mode
-    if debug_mode:
-        console_formatter = logging.Formatter("[%(asctime)s] %(message)s", datefmt="%H:%M:%S")
-        console_handler = logging.StreamHandler(sys.stdout)
-        console_handler.setFormatter(console_formatter)
-        logger.addHandler(console_handler)
-    launcher_log_file = log_dir / "launcher.log"
-    file_formatter = logging.Formatter("[%(asctime)s] [%(levelname)-8s] %(message)s")
-    file_handler = logging.FileHandler(launcher_log_file, mode='w', encoding='utf-8')
-    file_handler.setFormatter(file_formatter)
-    logger.addHandler(file_handler)
-
-    logger.info("=" * 50)
-    logger.info("Launcher logger initialized for new session.")
-    return logger
-
-
-# --- Log File Rotation and Cleanup Utilities ---
-
-def _rotate_log_file(log_dir: Path, archive_dir: Path, basename: str):
-    log_file = log_dir / basename
-    if log_file.exists():
-        if log_file.stat().st_size > 0: 
-            try:
-                timestamp = datetime.fromtimestamp(log_file.stat().st_mtime).strftime("%Y-%m-%d_%H-%M-%S")
-                base, ext = os.path.splitext(basename)
-                rotated_name = f"{base}_{timestamp}{ext}"
-                destination = archive_dir / rotated_name
-                
-                counter = 0
-                while destination.exists():
-                    counter += 1
-                    rotated_name = f"{base}_{timestamp}_{counter}{ext}"
-                    destination = archive_dir / rotated_name
-                
-                os.rename(log_file, destination) 
-                logging.info(f"Rotated previous log '{log_file.name}' to archive as '{destination.name}'")
-            except Exception as e:
-                logging.error(f"Could not rotate log file {log_file}: {e}", exc_info=True)
-        else: 
-            try:
-                os.unlink(log_file)
-                logging.info(f"Deleted empty previous log file: {log_file.name}")
-            except Exception as e:
-                logging.error(f"Could not delete empty log file {log_file}: {e}", exc_info=True)
-
-
-def _cleanup_backups(archive_dir: Path, base_name: str, max_count: int, max_age_days: int):
-    # Use the "ComfyUILauncher" logger, which should be configured by the time this is seriously used.
-    cleanup_logger = logging.getLogger("ComfyUILauncher")
-    cleanup_logger.info(f"Cleaning up old '{base_name}' logs from archive: {archive_dir}")
-    try:
-        now = datetime.now()
-        
-        backup_logs = sorted(
-            archive_dir.glob(f"{base_name}_*.log"),
-            key=lambda p: p.stat().st_mtime,
-            reverse=True
-        )
-        
-        cleanup_logger.debug(f"Found {len(backup_logs)} archived '{base_name}' logs for potential cleanup.")
-
-        files_to_delete = set()
-        
-        for i, log_file in enumerate(backup_logs):
-            age = now - datetime.fromtimestamp(log_file.stat().st_mtime)
-            marked_for_deletion_this_file = False
-            reason_parts = []
-
-            if age.days >= max_age_days:
-                marked_for_deletion_this_file = True
-                reason_parts.append(f"age {age.days}d >= {max_age_days}d")
-            
-            if i >= max_count: 
-                marked_for_deletion_this_file = True
-                reason_parts.append(f"index {i} >= files_to_keep_count {max_count}")
-            
-            if marked_for_deletion_this_file:
-                files_to_delete.add(log_file)
-                cleanup_logger.debug(f"Marking for deletion: {log_file.name} (Reason: {'; '.join(reason_parts)})")
-        
-        if not files_to_delete:
-            cleanup_logger.info(f"No old '{base_name}' logs from '{archive_dir}' met criteria for deletion.")
-            return
-
-        cleanup_logger.debug(f"Files actually marked for deletion: {[f.name for f in files_to_delete]}")
-        for log_file_to_delete in files_to_delete:
-            try:
-                cleanup_logger.debug(f"Attempting to os.unlink: {log_file_to_delete}")
-                os.unlink(log_file_to_delete) 
-                cleanup_logger.info(f"🗑️ Deleted archived log: {log_file_to_delete.name}")
-            except OSError as e:
-                cleanup_logger.warning(f"Could not delete archived log {log_file_to_delete.name}: {e}")
-            
-    except Exception as e:
-        cleanup_logger.error(f"An error occurred during log cleanup for '{base_name}' in {archive_dir}: {e}", exc_info=True)
-
-
-def rotate_and_cleanup_logs(log_dir: Path, max_files_to_keep_in_archive: int, max_log_age_days: int):
-    archive_dir = log_dir / "archive"
-    log_dir.mkdir(parents=True, exist_ok=True)
-    archive_dir.mkdir(exist_ok=True) 
-    
-    logging.info(f"Rotating previous session logs (if any) into: {archive_dir}")
-    _rotate_log_file(log_dir, archive_dir, "launcher.log")
-    _rotate_log_file(log_dir, archive_dir, "server.log")
-
-    logging.info(f"Cleaning up old archived logs...")
-    _cleanup_backups(archive_dir, "launcher", max_files_to_keep_in_archive, max_log_age_days)
-    _cleanup_backups(archive_dir, "server", max_files_to_keep_in_archive, max_log_age_days)
\ No newline at end of file
diff --git a/comfy_launcher/tray_manager.py b/comfy_launcher/tray_manager.py
index 4de2ed8..d8eb8fb 100644
--- a/comfy_launcher/tray_manager.py
+++ b/comfy_launcher/tray_manager.py
@@ -10,6 +10,7 @@ if TYPE_CHECKING:
     from .gui_manager import GUIManager
     # from .server_manager import ServerManager # Not directly used by TrayManager actions yet
     # from .config import Settings
+from . import event_publisher, AppEventType # Import the global event publisher
 
 class TrayManager:
     def __init__(self, app_name: str, assets_dir: Path, logger: 'Logger',
@@ -23,57 +24,37 @@ class TrayManager:
         self._gui_manager = gui_manager
         # self.server_manager: Optional['ServerManager'] = None # Keep if needed later
 
-    def _on_show_hide_window_selected(self):
-        self.logger.info("Tray: Show/Hide Window clicked.")
-        if self._gui_manager and self._gui_manager.webview_window:
-            # pywebview doesn't have a direct is_visible or is_hidden property reliably across backends.
-            # We'll try to use the 'hidden' attribute if available (pywebview 4.0+)
-            # or just call show() which might toggle or bring to front.
-            try:
-                if getattr(self._gui_manager.webview_window, 'hidden', False): # Check if 'hidden' attr exists and is True
-                    self._gui_manager.webview_window.show()
-                    self.logger.info("Tray: Showing window.")
-                else:
-                    # If not hidden or 'hidden' attribute doesn't exist, try hiding.
-                    # If it was already visible, this hides it. If it was hidden, this might do nothing or error.
-                    # A more robust solution might involve GUIManager tracking its own visibility state.
-                    self._gui_manager.webview_window.hide()
-                    self.logger.info("Tray: Hiding window.")
-            except Exception as e: # Catch potential errors if .hidden or .show/.hide misbehave
-                self.logger.warning(f"Tray: Error toggling window visibility: {e}. Attempting to show.")
-                try:
-                    self._gui_manager.webview_window.show() # Fallback to just showing
-                except Exception as e_show:
-                    self.logger.error(f"Tray: Fallback show() also failed: {e_show}")
-        else:
-            self.logger.warning("Tray: GUI manager or window not available to show/hide.")
+        event_publisher.subscribe(AppEventType.APPLICATION_QUIT_REQUESTED, self.handle_application_quit_request)
+        event_publisher.subscribe(AppEventType.GUI_WINDOW_HIDDEN, self.handle_gui_window_hidden)
 
 
     def _on_quit_selected(self):
-        self.logger.info("Tray: Quit selected. Signaling application shutdown.")
-        self._shutdown_event.set()
+        self.logger.info("Tray: Quit selected. Setting global shutdown event and publishing APPLICATION_QUIT_REQUESTED event.")
+        self._shutdown_event.set() # Signal background threads and main thread loop
+        event_publisher.publish(AppEventType.APPLICATION_QUIT_REQUESTED)
+        # The GUIManager will be signaled via the published event.
+        # self.icon.stop() will be handled by this class's own handler for APPLICATION_QUIT_REQUESTED.
+
+    def handle_application_quit_request(self):
+        """Handler for APPLICATION_QUIT_REQUESTED event to stop the tray icon."""
+        self.logger.info("Handler: APPLICATION_QUIT_REQUESTED received by TrayManager. Stopping tray icon.")
         if self.icon:
-            self.icon.stop()
+            self.icon.stop() # Stop the tray icon itself
+        # This handler's job is to stop the icon. The run() method publishes TRAY_MANAGER_SHUTDOWN_COMPLETE when its loop ends.
 
     def _create_menu(self) -> Optional[TrayMenu]:
         if not TrayMenu or not TrayMenuItem:
-            self.logger.warning("TrayManager: pystray.Menu or MenuItem not available. Cannot create menu.")
+            self.logger.warning("pystray.Menu or MenuItem not available. Cannot create menu.")
             return None
-        
-        item_show_hide = TrayMenuItem(
-            "Show/Hide Window",
-            self._on_show_hide_window_selected,
-            enabled=True # Enable this action
-        )
         item_quit = TrayMenuItem(
             "Quit Application", # More descriptive
             self._on_quit_selected,
             enabled=True # Enable this action
         )
-        return TrayMenu(item_show_hide, item_quit)
+        return TrayMenu(item_quit)
 
     def run(self):
-        self.logger.info("TrayManager: Initializing tray icon...")
+        self.logger.info("Initializing tray icon...")
         try:
             icon_path = self.assets_dir / "icon.png"
             if not icon_path.exists():
@@ -84,41 +65,49 @@ class TrayManager:
 
             menu = self._create_menu()
             if not menu: # If menu creation failed (e.g., pystray components not available)
-                self.logger.error("TrayManager: Failed to create tray menu. Cannot start tray icon.")
+                self.logger.error("Failed to create tray menu. Cannot start tray icon.")
                 return
 
             self.icon = TrayIcon(self.app_name, image, self.app_name, menu)
-            self.logger.info("TrayManager: Starting tray icon event loop...")
+            self.logger.info("Starting tray icon event loop...")
             self.icon.run()
-            self.logger.info("TrayManager: Tray icon event loop finished.")
+            self.logger.info("Tray icon event loop finished.")
+            # Publish event indicating tray manager has completed its run phase
+            event_publisher.publish(AppEventType.TRAY_MANAGER_SHUTDOWN_COMPLETE)
         except Exception as e:
-            self.logger.error(f"TrayManager: Failed to run tray icon: {e}", exc_info=True)
+            self.logger.error(f"Failed to run tray icon: {e}", exc_info=True)
             # If tray fails critically, we might want to signal shutdown to prevent a zombie app
             if not self._shutdown_event.is_set():
-                 self.logger.info("TrayManager: Signaling app shutdown due to critical tray error.")
+                 self.logger.info("Signaling app shutdown due to critical tray error.")
                  self._shutdown_event.set()
 
 
     def start(self):
         if not TrayIcon: # Check if pystray is available
-            self.logger.warning("TrayManager: pystray.Icon not available. Tray icon will not be started.")
+            self.logger.warning("pystray.Icon not available. Tray icon will not be started.")
             return
 
         if self._thread is None or not self._thread.is_alive():
             self._thread = threading.Thread(target=self.run, daemon=True, name="TrayIconThread")
             self._thread.start()
-            self.logger.info("TrayManager: Thread started.")
+            self.logger.info("Thread started.")
         else:
-            self.logger.info("TrayManager: Thread already alive.")
+            self.logger.info("Thread already alive.")
 
 
     def stop(self):
-        self.logger.info("TrayManager: Stopping tray icon...")
+        self.logger.info("Stopping tray icon...")
         if self.icon:
             self.icon.stop()
         if self._thread and self._thread.is_alive():
-            self.logger.debug("TrayManager: Waiting for tray thread to join...")
+            self.logger.debug("Waiting for tray thread to join...")
             self._thread.join(timeout=2)
             if self._thread.is_alive():
-                self.logger.warning("TrayManager: Tray thread did not join cleanly.")
-        self.logger.info("TrayManager: Tray icon stopped.")
+                self.logger.warning("Tray thread did not join cleanly.")
+        self.logger.info("Tray icon stopped.")
+
+    def handle_gui_window_hidden(self):
+        """Handles the GUI_WINDOW_HIDDEN event to update the tray menu if needed."""
+        self.logger.debug("TrayManager: GUI_WINDOW_HIDDEN event received. Updating menu.")
+        if self.icon:
+            self.icon.update_menu()
diff --git a/tests/test_gui_manager.py b/tests/test_gui_manager.py
index d4efea4..cd8bedf 100644
--- a/tests/test_gui_manager.py
+++ b/tests/test_gui_manager.py
@@ -1,5 +1,5 @@
 import unittest
-from unittest.mock import patch, MagicMock, call, mock_open
+from unittest.mock import patch, MagicMock, call, mock_open, ANY
 from pathlib import Path
 import threading
 import time 
@@ -13,6 +13,7 @@ if str(project_root) not in sys.path:
 
 from comfy_launcher.gui_manager import GUIManager
 from comfy_launcher.config import settings # Using the actual settings object
+from comfy_launcher.event_system import AppEventType # For testing event publishing
 
 import logging
 logging.disable(logging.CRITICAL)
@@ -250,7 +251,8 @@ class TestGuiManager(unittest.TestCase):
                 html="<html>Mocked Content</html>",
                 width=self.gui_manager.window_width,
                 height=self.gui_manager.window_height,
-                resizable=True
+                resizable=True,
+                confirm_close=False 
             )
             loaded_event_mock.__iadd__.assert_called_with(self.gui_manager.on_loaded)
             shown_event_mock.__iadd__.assert_called_with(self.gui_manager.on_shown)
@@ -278,7 +280,7 @@ class TestGuiManager(unittest.TestCase):
         self.gui_manager.on_loaded()
 
         self.assertTrue(self.gui_manager.is_window_loaded.is_set())
-        self.mock_logger.debug.assert_any_call("Signaling that initial window content is loaded.")
+        self.mock_logger.debug.assert_any_call("Initial window content loaded. Publishing GUI_WINDOW_CONTENT_LOADED event.")
 
     def test_on_loaded_subsequent_times_settings_page(self):
         self.gui_manager.is_window_loaded.set() 
@@ -312,13 +314,13 @@ class TestGuiManager(unittest.TestCase):
         self.gui_manager.webview_window = MagicMock() 
         with patch('comfy_launcher.gui_manager.settings.DEBUG', True):
             self.gui_manager.start_webview_blocking()
-            mock_webview_module.start.assert_called_once_with(debug=True, private_mode=False, http_server=True)
+            mock_webview_module.start.assert_called_once_with(debug=True, private_mode=False, http_server=False)
 
         mock_webview_module.start.reset_mock() 
         
         with patch('comfy_launcher.gui_manager.settings.DEBUG', False):
             self.gui_manager.start_webview_blocking()
-            mock_webview_module.start.assert_called_once_with(debug=False, private_mode=False, http_server=True)
+            mock_webview_module.start.assert_called_once_with(debug=False, private_mode=False, http_server=False)
 
     def test_py_toggle_devtools_debug_true(self):
         self.gui_manager.webview_window = MagicMock() 
@@ -334,5 +336,175 @@ class TestGuiManager(unittest.TestCase):
             self.gui_manager.webview_window.toggle_devtools.assert_not_called()
             self.mock_logger.info.assert_any_call("Developer Tools are disabled (DEBUG mode is off).")
 
+    @patch('comfy_launcher.gui_manager.event_publisher.publish')
+    def test_on_closing_event_handler(self, mock_event_publish):
+        self.gui_manager.webview_window = MagicMock(name="MockWebviewWindow")
+        mock_gui_event = MagicMock(name="MockGuiClosingEvent")
+        mock_gui_event.cancel = MagicMock()
+
+        self.gui_manager._on_closing(event=mock_gui_event) # Pass as keyword arg
+
+        self.assertEqual(mock_gui_event.cancel, True, "event.cancel should have been set to True")
+        self.gui_manager.webview_window.hide.assert_called_once()
+        mock_event_publish.assert_called_once_with(AppEventType.APPLICATION_QUIT_REQUESTED)
+        self.mock_logger.info.assert_called_once_with(
+            "Window close event received (_on_closing). Publishing APPLICATION_QUIT_REQUESTED."
+        )
+        # Ensure is_window_shown is cleared
+        self.assertFalse(self.gui_manager.is_window_shown.is_set(), "is_window_shown should be cleared when window is hidden.")
+
+    def test_on_shown_handler(self):
+        self.gui_manager.is_window_shown.clear() # Ensure it's not set initially
+        
+        self.gui_manager.on_shown() # The method being tested
+
+        self.assertTrue(self.gui_manager.is_window_shown.is_set())
+        self.mock_logger.debug.assert_called_once_with("Webview 'shown' event fired. Window is visible on screen.")
+
+    @patch('comfy_launcher.gui_manager.event_publisher.publish') # If it publishes events
+    def test_handle_critical_error_event_loads_page(self, mock_event_publish):
+        test_error_message = "Something went terribly wrong!"
+        self.gui_manager.load_critical_error_page = MagicMock() # Mock the method that loads the page
+
+        # Simulate the event being handled
+        self.gui_manager.handle_critical_error_event(message=test_error_message)
+
+        self.gui_manager.load_critical_error_page.assert_called_once_with(test_error_message)
+        self.mock_logger.info.assert_any_call(f"Event Handler: Received APPLICATION_CRITICAL_ERROR: {test_error_message}")
+
+    # Patch where app_shutdown_event is imported and used within the SUT method
+    @patch('comfy_launcher.__main__.app_shutdown_event') 
+    def test_handle_server_stopped_unexpectedly_event_not_shutting_down(self, mock_app_shutdown_event):
+        mock_app_shutdown_event.is_set.return_value = False
+        self.gui_manager.load_error_page = MagicMock()
+        test_pid = 123
+        test_returncode = 1
+
+        self.gui_manager.handle_server_stopped_unexpectedly_event(pid=test_pid, returncode=test_returncode)
+
+        expected_message = f"ComfyUI server (PID: {test_pid}) stopped unexpectedly with code {test_returncode}. Check server.log."
+        self.gui_manager.load_error_page.assert_called_once_with(expected_message)
+        self.mock_logger.error.assert_any_call(f"Event Handler: Received SERVER_STOPPED_UNEXPECTEDLY (PID: {test_pid}, Code: {test_returncode}). Displaying error page.")
+
+    @patch('comfy_launcher.__main__.app_shutdown_event')
+    def test_handle_server_stopped_unexpectedly_event_already_shutting_down(self, mock_app_shutdown_event):
+        mock_app_shutdown_event.is_set.return_value = True
+        self.gui_manager.load_error_page = MagicMock()
+        test_pid = 456
+        test_returncode = 0
+
+        self.gui_manager.handle_server_stopped_unexpectedly_event(pid=test_pid, returncode=test_returncode)
+
+        self.gui_manager.load_error_page.assert_not_called()
+        self.mock_logger.info.assert_any_call(f"Event Handler: Received SERVER_STOPPED_UNEXPECTEDLY (PID: {test_pid}, Code: {test_returncode}), but app is already shutting down. No error page displayed.")
+
+    @patch('comfy_launcher.gui_manager.event_publisher.publish')
+    def test_handle_show_window_request_window_exists(self, mock_event_publish):
+        self.gui_manager.webview_window = MagicMock(name="MockWebviewWindow")
+        self.gui_manager.webview_window.activate = MagicMock() # Ensure activate method exists
+
+        self.gui_manager.handle_show_window_request()
+
+        self.gui_manager.webview_window.show.assert_called_once()
+        self.gui_manager.webview_window.activate.assert_called_once()
+        # Publishing SHOW_WINDOW_REQUEST_RELAYED_TO_GUI is optional in SUT, so don't assert strictly
+        # mock_event_publish.assert_called_once_with(AppEventType.SHOW_WINDOW_REQUEST_RELAYED_TO_GUI)
+        self.mock_logger.info.assert_any_call("Event Handler: Received SHOW_WINDOW_REQUEST. Attempting to show and activate GUI window.")
+
+    @patch('comfy_launcher.gui_manager.event_publisher.publish')
+    def test_handle_show_window_request_window_none(self, mock_event_publish):
+        self.gui_manager.webview_window = None
+
+        self.gui_manager.handle_show_window_request()
+
+        mock_event_publish.assert_not_called() # Should not relay if no window
+        self.mock_logger.warning.assert_any_call("Event Handler: Received SHOW_WINDOW_REQUEST, but webview_window is None. Cannot show.")
+
+    @patch('comfy_launcher.gui_manager.time.sleep', return_value=None) # Mock sleep to speed up test
+    def test_redirect_loop_server_available_redirects_and_sets_status(self, mock_sleep):
+        self.gui_manager.webview_window = MagicMock()
+        self.gui_manager.webview_window.load_url = MagicMock()
+        self.gui_manager.set_status = MagicMock()
+        self.mock_server_manager.wait_for_server_availability.return_value = True
+        
+        mock_redirect_stop_event = threading.Event()
+        mock_shutdown_event = threading.Event()
+
+        # To exit the loop after one successful iteration
+        self.gui_manager.webview_window.load_url.side_effect = lambda url: mock_redirect_stop_event.set()
+
+        self.gui_manager.redirect_when_ready_loop(mock_redirect_stop_event, mock_shutdown_event)
+
+        # The SUT calls wait_for_server_availability with specific retries/delay now
+        self.mock_server_manager.wait_for_server_availability.assert_called_once_with(retries=1, delay=0.1)
+        self.gui_manager.webview_window.load_url.assert_called_once_with(f"http://{self.gui_manager.connect_host}:{self.gui_manager.port}")
+        self.gui_manager.set_status.assert_called_with("Connected to ComfyUI.")
+        self.mock_logger.info.assert_any_call(f"Redirect loop: Server is available. Attempting to redirect webview to http://{self.gui_manager.connect_host}:{self.gui_manager.port}")
+
+    @patch('comfy_launcher.gui_manager.time.sleep', return_value=None)
+    @patch.object(GUIManager, 'load_error_page') # Patch the method
+    def test_redirect_loop_server_timeout_sets_error_status(self, mock_load_error_page, mock_sleep):
+        self.gui_manager.webview_window = MagicMock()
+        self.gui_manager.webview_window.load_url = MagicMock()
+        self.gui_manager.set_status = MagicMock()
+        self.mock_server_manager.wait_for_server_availability.return_value = False # Simulate timeout
+
+        mock_redirect_stop_event = threading.Event()
+        mock_shutdown_event = threading.Event()
+
+        # To exit the loop after one failed iteration
+        # The loop now has a max_wait_time, so we can let it timeout naturally or force stop_event
+        self.gui_manager.REDIRECT_LOOP_MAX_WAIT_TIME = 0.1 # Force quick timeout for test
+        # self.mock_server_manager.wait_for_server_availability.side_effect = lambda **kwargs: mock_redirect_stop_event.set() or False
+
+        self.gui_manager.redirect_when_ready_loop(mock_redirect_stop_event, mock_shutdown_event)
+
+        self.gui_manager.webview_window.load_url.assert_not_called()
+        mock_load_error_page.assert_called_with("ComfyUI server did not become available in time. Please check server logs.")
+        self.mock_logger.warning.assert_any_call("Redirect loop: Max wait time exceeded for server availability.")
+
+    def test_get_asset_content_file_not_found_non_critical(self):
+        # Mock assets_dir to control path resolution
+        mock_assets_dir = MagicMock(spec=Path)
+        mock_non_existent_path = MagicMock(spec=Path)
+        mock_non_existent_path.exists.return_value = False
+        mock_non_existent_path.name = "non_existent.js" # For logging
+        mock_assets_dir.__truediv__.return_value = mock_non_existent_path
+        self.gui_manager.assets_dir = mock_assets_dir
+
+        content = self.gui_manager._get_asset_content("non_existent.js")
+
+        self.assertEqual(content, "")
+        self.mock_logger.error.assert_any_call(f"Asset file not found: {mock_non_existent_path}")
+
+    def test_get_asset_content_file_not_found_critical_fallback(self):
+        mock_assets_dir = MagicMock(spec=Path)
+        mock_non_existent_path = MagicMock(spec=Path)
+        mock_non_existent_path.exists.return_value = False
+        mock_non_existent_path.name = "critical_asset.html"
+        mock_assets_dir.__truediv__.return_value = mock_non_existent_path
+        self.gui_manager.assets_dir = mock_assets_dir
+
+        content = self.gui_manager._get_asset_content("critical_asset.html", is_critical_fallback=True)
+
+        self.assertIn("<h1>Critical Error</h1>", content) # Check for part of the fallback HTML
+        self.assertIn("If you're seeing this, the application encountered a severe issue", content)
+        self.mock_logger.error.assert_any_call(f"Asset file not found: {mock_non_existent_path}")
+        self.mock_logger.critical.assert_any_call(f"Critical asset 'critical_asset.html' not found, and no fallback content available other than the hardcoded one.")
+
+    def test_execute_js_no_window(self):
+        self.gui_manager.webview_window = None
+        self.gui_manager._execute_js("console.log('test');")
+        self.mock_logger.debug.assert_any_call("Cannot execute JS, webview_window is None.")
+
+    def test_execute_js_webview_error(self):
+        self.gui_manager.webview_window = MagicMock()
+        self.gui_manager.webview_window.evaluate_js.side_effect = Exception("JS execution failed")
+        
+        self.gui_manager._execute_js("test_function();")
+        
+        self.mock_logger.error.assert_any_call("Error executing JavaScript in webview: JS execution failed", exc_info=True)
+
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/tests/test_logger_setup.py b/tests/test_logger_setup.py
deleted file mode 100644
index 5f22771..0000000
--- a/tests/test_logger_setup.py
+++ /dev/null
@@ -1,172 +0,0 @@
-import unittest
-from unittest.mock import patch, MagicMock, call
-from pathlib import Path
-import logging
-import tempfile
-from datetime import datetime, timedelta
-import os 
-
-import sys
-project_root = Path(__file__).resolve().parent.parent
-if str(project_root) not in sys.path:
-    sys.path.insert(0, str(project_root))
-
-from comfy_launcher.logger_setup import setup_launcher_logger, rotate_and_cleanup_logs, _rotate_log_file, _cleanup_backups
-
-class TestLoggerSetup(unittest.TestCase):
-
-    def setUp(self):
-        self.temp_dir_obj = tempfile.TemporaryDirectory()
-        self.temp_dir = Path(self.temp_dir_obj.name)
-        
-        self.patcher = patch('comfy_launcher.logger_setup.logging.getLogger')
-        self.mock_get_logger = self.patcher.start()
-        
-        self.mock_logger_instance = MagicMock(spec=logging.Logger)
-        self.mock_logger_instance.handlers = [] 
-        self.mock_logger_instance.hasHandlers.return_value = False
-        self.mock_get_logger.return_value = self.mock_logger_instance
-
-        # No longer patching builtins.print by default
-        # self.print_patcher = patch('builtins.print')
-        # self.mock_print = self.print_patcher.start()
-
-    def tearDown(self):
-        self.temp_dir_obj.cleanup()
-        self.patcher.stop()
-        # self.print_patcher.stop() # No longer patching print
-
-    def test_setup_launcher_logger_debug_mode(self):
-        self.mock_logger_instance.reset_mock() 
-        self.mock_logger_instance.handlers = []
-        self.mock_logger_instance.hasHandlers.return_value = False 
-
-        logger = setup_launcher_logger(self.temp_dir, debug_mode=True)
-        
-        self.mock_get_logger.assert_called_with("ComfyUILauncher")
-        self.mock_logger_instance.setLevel.assert_called_with(logging.DEBUG)
-        self.assertGreaterEqual(self.mock_logger_instance.addHandler.call_count, 2)
-
-        mock_handler1 = MagicMock(spec=logging.Handler)
-        mock_handler2 = MagicMock(spec=logging.Handler)
-        
-        self.mock_logger_instance.reset_mock() 
-        self.mock_logger_instance.handlers = [mock_handler1, mock_handler2]
-        self.mock_logger_instance.hasHandlers.return_value = True
-        
-        logger_again = setup_launcher_logger(self.temp_dir, debug_mode=True)
-        
-        mock_handler1.close.assert_called_once()
-        mock_handler2.close.assert_called_once()
-        self.mock_logger_instance.removeHandler.assert_has_calls(
-            [call(mock_handler1), call(mock_handler2)], any_order=True
-        )
-        self.assertGreaterEqual(self.mock_logger_instance.addHandler.call_count, 2)
-
-
-    def test_setup_launcher_logger_production_mode(self):
-        self.mock_logger_instance.reset_mock()
-        self.mock_logger_instance.handlers = []
-        self.mock_logger_instance.hasHandlers.return_value = False
-
-        logger = setup_launcher_logger(self.temp_dir, debug_mode=False)
-        self.mock_get_logger.assert_called_with("ComfyUILauncher")
-        self.mock_logger_instance.setLevel.assert_called_with(logging.INFO)
-
-    @patch('comfy_launcher.logger_setup.datetime')
-    @patch('comfy_launcher.logger_setup.os.rename')
-    def test_rotate_log_file(self, mock_os_rename, mock_datetime_module):
-        mock_file_mtime = datetime(2023, 1, 1, 12, 0, 0)
-        mock_datetime_module.fromtimestamp.return_value = mock_file_mtime
-
-        archive_dir = self.temp_dir / "archive"
-        archive_dir.mkdir()
-
-        log_file_to_rotate = self.temp_dir / "test.log"
-        log_file_to_rotate.write_text("some log data") 
-        
-        _rotate_log_file(self.temp_dir, archive_dir, "test.log")
-        
-        expected_rotated_name = f"test_{mock_file_mtime.strftime('%Y-%m-%d_%H-%M-%S')}.log"
-        expected_target_path = archive_dir / expected_rotated_name
-        
-        mock_os_rename.assert_called_once_with(log_file_to_rotate, expected_target_path)
-
-    @patch('comfy_launcher.logger_setup.datetime') # This mock_datetime_module is for the SUT
-    @patch('comfy_launcher.logger_setup.os.unlink')
-    def test_cleanup_backups_by_age_and_count(self, mock_os_unlink, mock_datetime_module_sut): # Renamed mock for clarity
-        # Use the real datetime for setting up 'now' in the test
-        now_for_test = datetime(2023, 1, 10, 12, 0, 0)
-        mock_datetime_module_sut.now.return_value = now_for_test 
-
-        # Configure SUT's datetime.fromtimestamp to call the REAL datetime.fromtimestamp
-        # This requires importing the real datetime module with an alias in the test file
-        # (already done at the top of this file in previous versions)
-        # If 'real_datetime_module' alias isn't set up, this line will fail.
-        # Assuming 'import datetime as real_datetime_module' is at the top.
-        # For clarity, let's ensure it's explicitly available if not imported with that alias:
-        import datetime as actual_datetime_for_side_effect
-        mock_datetime_module_sut.fromtimestamp.side_effect = actual_datetime_for_side_effect.datetime.fromtimestamp
-
-
-        archive_dir = self.temp_dir / "archive" 
-        archive_dir.mkdir(exist_ok=True)
-
-        log_files_data = {
-            "prefix_2023-01-09_10-00-00.log": (now_for_test - timedelta(days=1)),
-            "prefix_2023-01-08_10-00-00.log": (now_for_test - timedelta(days=2)),
-            "prefix_2023-01-07_10-00-00.log": (now_for_test - timedelta(days=3)),
-            "prefix_2023-01-06_10-00-00.log": (now_for_test - timedelta(days=4)),
-            "prefix_2023-01-05_10-00-00.log": (now_for_test - timedelta(days=5)),
-            "prefix_2023-01-04_10-00-00.log": (now_for_test - timedelta(days=6))
-        }
-        
-        created_file_path_objects = {}
-        for name, dt_obj in log_files_data.items():
-            file_path = archive_dir / name
-            file_path.write_text("dummy log content")
-            os.utime(file_path, (dt_obj.timestamp(), dt_obj.timestamp()))
-            created_file_path_objects[name] = file_path 
-        
-        _cleanup_backups(archive_dir=archive_dir, base_name="prefix", max_count=2, max_age_days=3)
-
-        expected_deleted_paths = {
-            created_file_path_objects["prefix_2023-01-07_10-00-00.log"],
-            created_file_path_objects["prefix_2023-01-06_10-00-00.log"],
-            created_file_path_objects["prefix_2023-01-05_10-00-00.log"],
-            created_file_path_objects["prefix_2023-01-04_10-00-00.log"]
-        }
-            
-        called_unlink_on_paths = set()
-        if mock_os_unlink.called:
-            for call_args_tuple in mock_os_unlink.call_args_list:
-                called_unlink_on_paths.add(call_args_tuple[0][0]) 
-        
-        self.assertSetEqual(called_unlink_on_paths, expected_deleted_paths)
-
-
-    @patch('comfy_launcher.logger_setup._rotate_log_file')
-    @patch('comfy_launcher.logger_setup._cleanup_backups')
-    def test_rotate_and_cleanup_logs_orchestration(self, mock_cleanup, mock_rotate):
-        log_dir = self.temp_dir / "logs" 
-        archive_dir_expected = log_dir / "archive"
-        max_files = 3 
-        max_age_days = 5
-        
-        rotate_and_cleanup_logs(log_dir, max_files, max_age_days)
-        
-        self.assertTrue(log_dir.exists())
-        self.assertTrue(archive_dir_expected.exists())
-        
-        mock_rotate.assert_has_calls([
-            call(log_dir, archive_dir_expected, "launcher.log"),
-            call(log_dir, archive_dir_expected, "server.log")
-        ], any_order=True) 
-        
-        mock_cleanup.assert_has_calls([
-            call(archive_dir_expected, "launcher", max_files, max_age_days),
-            call(archive_dir_expected, "server", max_files, max_age_days)
-        ], any_order=True)
-
-if __name__ == '__main__':
-    unittest.main()
\ No newline at end of file
diff --git a/tests/test_main.py b/tests/test_main.py
index 4d3436b..e9c630f 100644
--- a/tests/test_main.py
+++ b/tests/test_main.py
@@ -1,7 +1,7 @@
 import unittest
 from unittest.mock import patch, MagicMock, call
 from pathlib import Path
-import threading # Keep for spec
+import threading as python_threading # Alias for actual threading module to avoid patch conflicts
 import logging
 import subprocess # For spec in app_logic_thread_func test
 
@@ -14,45 +14,58 @@ from comfy_launcher import __main__ as launcher_main_module
 from comfy_launcher.gui_manager import GUIManager
 from comfy_launcher.server_manager import ServerManager
 from comfy_launcher.tray_manager import TrayManager # For spec
-# Import the function we need to test directly if it's not too complex to call
+# Import functions and event handlers we need to test directly
 from comfy_launcher.__main__ import app_logic_thread_func
 
 
 @patch('comfy_launcher.__main__.TrayManager')
 class TestMainExecution(unittest.TestCase):
+    # Store the original Event class before any patches
+    OriginalEventClass = python_threading.Event
 
 
     @patch('comfy_launcher.__main__.app_logic_thread_func') # Patch the function directly
     @patch('comfy_launcher.__main__.time.sleep', return_value=None) # Keep if app_logic_thread_func uses it
     @patch('comfy_launcher.__main__.GUIManager')
     @patch('comfy_launcher.__main__.ServerManager')
-    @patch('comfy_launcher.__main__.rotate_and_cleanup_logs')
-    @patch('comfy_launcher.__main__.setup_launcher_logger')
+    @patch('comfy_launcher.__main__.LogManager')
     @patch('comfy_launcher.__main__.settings')
-    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=threading.Event))
-    def test_main_orchestration_and_shutdown( # Order: innermost @patch first, then class @patch
-            self, mock_app_shutdown_event_p,    # from @patch('...app_shutdown_event')
-            mock_settings_p,                # from @patch('...settings')
-            mock_setup_logger_p,            # from @patch('...setup_launcher_logger')
-            mock_rotate_cleanup_p,          # from @patch('...rotate_and_cleanup_logs')
-            MockServerManager_p,            # from @patch('...ServerManager')
-            MockGUIManager_p,               # from @patch('...GUIManager')
-            mock_time_sleep_p,              # from @patch('...time.sleep')
-            mock_app_logic_thread_func_p,   # from @patch('...app_logic_thread_func')
-            MockTrayManager_class_level_p ):# From class decorator
+    # Patch global event instances, speccing against the original Event class
+    @patch('comfy_launcher.__main__._app_logic_completed_event', new_callable=lambda: MagicMock(spec=TestMainExecution.OriginalEventClass))
+    @patch('comfy_launcher.__main__._tray_manager_completed_event', new_callable=lambda: MagicMock(spec=TestMainExecution.OriginalEventClass))
+    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=TestMainExecution.OriginalEventClass))
+    # Patch the Event class within __main__'s threading module, also speccing against the original
+    @patch('comfy_launcher.__main__.threading.Event', new_callable=lambda: unittest.mock.create_autospec(TestMainExecution.OriginalEventClass, instance=False))
+    def test_main_orchestration_and_shutdown(
+            self,
+            mock_sut_local_event_constructor_p, # from @patch('...threading.Event')
+            mock_app_shutdown_event_p,          # from @patch('...app_shutdown_event')
+            mock_tray_manager_completed_event_global_p, # from @patch('..._tray_manager_completed_event')
+            mock_app_logic_completed_event_global_p,    # from @patch('..._app_logic_completed_event')
+            mock_settings_p,
+            MockLogManager_p,
+            MockServerManager_p,
+            MockGUIManager_p,
+            mock_time_sleep_p,
+            mock_app_logic_thread_func_p,
+            MockTrayManager_class_level_p): # From class decorator
         """
-        Test the main orchestration flow: setup, GUI prep, thread start, webview start, and shutdown.
+        Test the main orchestration flow: LogManager init, GUI prep, thread start, webview start, and shutdown.
         The internal logic of app_logic_thread_func is tested separately.
         """
-        mock_logger_instance = MagicMock(spec=logging.Logger)
-        mock_setup_logger_p.return_value = mock_logger_instance
+        mock_log_manager_instance = MockLogManager_p.return_value
+        mock_logger_instance = MagicMock(spec=logging.Logger, name="MockLoggerInstance")
+        mock_log_manager_instance.get_launcher_logger.return_value = mock_logger_instance
 
         mock_gui_instance = MockGUIManager_p.return_value
         mock_server_instance = MockServerManager_p.return_value
         mock_tray_instance = MockTrayManager_class_level_p.return_value
 
+        # _app_logic_completed_event and _tray_manager_completed_event are now global and patched directly.
+        # mock_sut_local_event_constructor_p will catch any *other* threading.Event() calls within main.py if they exist.
+        # No need for: mock_sut_event_constructor_p.side_effect = [...]
+
         # Simulate app_shutdown_event.wait() being unblocked by app_shutdown_event.set()
-        # This is a simplified way; a more complex side_effect could be used if needed.
         def shutdown_side_effect():
             mock_app_shutdown_event_p.set() # Simulate something setting the event
         mock_gui_instance.start_webview_blocking.side_effect = shutdown_side_effect
@@ -73,18 +86,18 @@ class TestMainExecution(unittest.TestCase):
         mock_settings_p.EFFECTIVE_CONNECT_HOST = mock_settings_p.HOST
 
         # --- Simulate main execution ---
-        # Patch threading.Thread to capture its arguments and control its behavior
         with patch('comfy_launcher.__main__.threading.Thread') as MockAppThread:
             mock_thread_instance = MockAppThread.return_value
             launcher_main_module.main()
 
             # 1. Initial setup assertions
-            mock_rotate_cleanup_p.assert_called_once_with(
-                mock_settings_p.LOG_DIR, mock_settings_p.MAX_LOG_FILES, mock_settings_p.MAX_LOG_AGE_DAYS
-            )
-            mock_setup_logger_p.assert_called_once_with(
-                mock_settings_p.LOG_DIR, mock_settings_p.DEBUG
+            MockLogManager_p.assert_called_once_with(
+                log_dir=mock_settings_p.LOG_DIR,
+                debug_mode=mock_settings_p.DEBUG,
+                max_files_to_keep_in_archive=mock_settings_p.MAX_LOG_FILES,
+                max_log_age_days=mock_settings_p.MAX_LOG_AGE_DAYS
             )
+            mock_log_manager_instance.get_launcher_logger.assert_called_once()
 
             # 2. Manager instantiation
             MockServerManager_p.assert_called_once_with(
@@ -109,13 +122,13 @@ class TestMainExecution(unittest.TestCase):
                 app_name=mock_settings_p.APP_NAME,
                 assets_dir=mock_settings_p.ASSETS_DIR,
                 logger=mock_logger_instance,
-                shutdown_event=mock_app_shutdown_event_p, # Check new arg
-                gui_manager=mock_gui_instance          # Check new arg
+                shutdown_event=mock_app_shutdown_event_p,
+                gui_manager=mock_gui_instance
             )
 
             # 3. GUI preparation
             mock_gui_instance.prepare_and_launch_gui.assert_called_once_with(
-                shutdown_event_for_critical_error=mock_app_shutdown_event_p # Check new arg
+                shutdown_event_for_critical_error=mock_app_shutdown_event_p
             )
 
             # 3.5 Tray Manager start
@@ -124,9 +137,9 @@ class TestMainExecution(unittest.TestCase):
             # 4. Assert app_logic_thread was created and started correctly
             expected_server_log_path = mock_settings_p.LOG_DIR / "server.log"
             MockAppThread.assert_called_once_with(
-                target=launcher_main_module.app_logic_thread_func, # Check it's the right function
+                target=launcher_main_module.app_logic_thread_func,
                 args=(mock_logger_instance, mock_gui_instance, mock_server_instance,
-                      expected_server_log_path, mock_app_shutdown_event_p), # Check new arg
+                      expected_server_log_path, mock_app_shutdown_event_p),
                 daemon=True
             )
             mock_thread_instance.start.assert_called_once()
@@ -137,34 +150,27 @@ class TestMainExecution(unittest.TestCase):
             # 5.5 Assert app_shutdown_event.wait() was called
             mock_app_shutdown_event_p.wait.assert_called_once()
 
-            # 6. Shutdown sequence (after webview_blocking returns)
-            mock_app_shutdown_event_p.set.assert_called() # Ensure it was set to unblock wait
+            # 6. Shutdown sequence
+            mock_app_shutdown_event_p.set.assert_called()
 
             self.assertEqual(launcher_main_module.server_manager_instance, mock_server_instance)
             self.assertEqual(launcher_main_module.tray_manager_instance, mock_tray_instance)
 
-            # Server shutdown is now primarily in app_logic_thread_func, but main does a final check
-            # If server_process is None or already polled, shutdown_server won't be called from main's finally
-            # This assertion might need to be more nuanced or removed if app_logic_thread handles it all.
-            # For now, let's assume it might be called if the process is still seen as running.
-            # mock_server_instance.shutdown_server.assert_called_once_with()
-
-            mock_tray_instance.stop.assert_called_once_with() # Check tray stop
-            mock_gui_instance.webview_window.destroy.assert_called_once() # Check GUI destroy
+            if mock_gui_instance.webview_window:
+                mock_gui_instance.webview_window.destroy.assert_called_once()
 
             # 7. Final logging
-            mock_logger_instance.info.assert_any_call(f"MAIN THREAD: {mock_settings_p.APP_NAME} has exited cleanly.")
-            # 8. Thread join
-            mock_thread_instance.join.assert_called_once_with(timeout=10)
-
+            mock_logger_instance.info.assert_any_call(f"{mock_settings_p.APP_NAME} has exited cleanly.")
+            mock_app_logic_completed_event_global_p.wait.assert_called_once_with(timeout=12)
+            mock_tray_manager_completed_event_global_p.wait.assert_called_once_with(timeout=5)
 
     @patch('comfy_launcher.__main__.time.sleep', return_value=None)
     @patch('comfy_launcher.__main__.threading.Thread')
-    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=threading.Event))
-    def test_app_logic_thread_func_successful_run(self, mock_app_shutdown_event_p, # from @patch('...app_shutdown_event')
-                                                mock_threading_Thread_p,      # from @patch('...threading.Thread')
-                                                mock_time_sleep_p,            # from @patch('...time.sleep')
-                                                MockTrayManager_class_level_param): # From class decorator
+    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=TestMainExecution.OriginalEventClass))
+    def test_app_logic_thread_func_successful_run(self, mock_app_shutdown_event_p,
+                                                mock_threading_Thread_p,
+                                                mock_time_sleep_p,
+                                                MockTrayManager_class_level_param):
         """
         Test the successful execution flow of app_logic_thread_func.
         """
@@ -172,145 +178,187 @@ class TestMainExecution(unittest.TestCase):
         mock_gui_manager = MagicMock(spec=GUIManager)
         mock_server_manager = MagicMock(spec=ServerManager)
         mock_server_log_path = Path("/fake/logs/server.log")
-        mock_shutdown_event = mock_app_shutdown_event_p # Use the one from the decorator
+        mock_shutdown_event = mock_app_shutdown_event_p
 
-        # Simulate GUI loaded successfully
-        mock_gui_manager.is_window_loaded = MagicMock(spec=threading.Event)
-        mock_gui_manager.is_window_loaded.wait.return_value = True
+        mock_event_publisher = MagicMock()
+        _gui_initial_content_loaded_event_for_test = self.OriginalEventClass()
 
-        mock_shutdown_event.is_set.return_value = False # Ensure initial checks pass
-        # Simulate server starting successfully
+        mock_shutdown_event.is_set.return_value = False
         mock_server_process_obj = MagicMock(spec=subprocess.Popen, pid=12345)
-        mock_server_process_obj.poll.return_value = None # Crucial: Simulate server is running initially
+        mock_server_process_obj.poll.return_value = None
         mock_server_manager.start_server.return_value = mock_server_process_obj
-        # Simulate server running and then shutdown_event being set
-        # More explicit side_effect for mock_shutdown_event.wait based on call order
+        
         _wait_call_count = 0
         def shutdown_wait_side_effect(timeout):
             nonlocal _wait_call_count
             _wait_call_count += 1
-            if _wait_call_count == 1: # First call, should be wait(0.5)
+            if _wait_call_count == 1:
                 self.assertEqual(timeout, 0.5, "First wait call should be 0.5s")
                 return False
-            elif _wait_call_count == 2: # Second call, should be wait(0.5)
+            elif _wait_call_count == 2:
                 self.assertEqual(timeout, 0.5, "Second wait call should be 0.5s")
                 return False
-            elif _wait_call_count == 3: # Third call, should be wait(timeout=1) in monitoring loop
+            elif _wait_call_count == 3:
                 self.assertEqual(timeout, 1, "Third wait call should be 1s timeout")
-                # Do NOT change poll.return_value here.
-                # Let the poll() in the finally block see the server as still running (None).
-                return True # Simulate event was set
-            # Should not be reached if logic is correct for this test
+                return True
             raise AssertionError(f"Unexpected call to shutdown_event.wait with timeout={timeout} at call_count={_wait_call_count}")
         mock_shutdown_event.wait.side_effect = shutdown_wait_side_effect
 
-
-        # Simulate settings for port
-        with patch('comfy_launcher.__main__.settings') as mock_main_settings:
+        with patch('comfy_launcher.__main__.settings') as mock_main_settings, \
+             patch('comfy_launcher.__main__.event_publisher', mock_event_publisher), \
+             patch('comfy_launcher.__main__.threading.Event', MagicMock(return_value=_gui_initial_content_loaded_event_for_test)):
+            
             mock_main_settings.PORT = 8188
+            _gui_initial_content_loaded_event_for_test.set()
+
             app_logic_thread_func(mock_app_logger, mock_gui_manager, mock_server_manager,
                                   mock_server_log_path, mock_shutdown_event)
 
-        # Assertions for app_logic_thread_func
-        mock_app_logger.info.assert_any_call("BACKGROUND THREAD: Started.")
-        mock_gui_manager.is_window_loaded.wait.assert_called_once_with(timeout=20)
-        mock_app_logger.info.assert_any_call("BACKGROUND THREAD: Waiting for GUI window to finish loading content...")
-        mock_app_logger.info.assert_any_call("BACKGROUND THREAD: GUI content loaded. Proceeding with server launch sequence.")
+        mock_app_logger.info.assert_any_call("Started.")
+        self.assertTrue(_gui_initial_content_loaded_event_for_test.is_set())
+        mock_app_logger.info.assert_any_call("Waiting for GUI window to finish loading initial content (via event)...")
+        mock_app_logger.info.assert_any_call("GUI content loaded. Proceeding with server launch sequence.")
 
         mock_gui_manager.set_status.assert_any_call("Initializing...")
-        mock_shutdown_event.wait.assert_any_call(0.5) # Check for waits
+        mock_shutdown_event.wait.assert_any_call(0.5)
 
         mock_gui_manager.set_status.assert_any_call(f"Clearing network port {mock_main_settings.PORT}...")
         mock_server_manager.kill_process_on_port.assert_called_once()
-
         mock_gui_manager.set_status.assert_any_call("Starting ComfyUI server process...")
         mock_server_manager.start_server.assert_called_once_with(mock_server_log_path)
 
-        # Assert the redirect_when_ready_loop thread was started
-        mock_redirect_stop_event_arg = mock_threading_Thread_p.call_args[1]['args'][0]
-        self.assertIsInstance(mock_redirect_stop_event_arg, threading.Event)
+        if mock_threading_Thread_p.called:
+            mock_redirect_stop_event_arg = mock_threading_Thread_p.call_args[1]['args'][0]
+            self.assertIsInstance(mock_redirect_stop_event_arg, python_threading.Event)
 
-        mock_threading_Thread_p.assert_called_once_with(
-            target=mock_gui_manager.redirect_when_ready_loop,
-            args=(mock_redirect_stop_event_arg, mock_shutdown_event), # Check new args
-            daemon=True
-        )
-        mock_threading_Thread_p.return_value.start.assert_called_once()
-        mock_app_logger.info.assert_any_call("BACKGROUND THREAD: Redirection loop initiated.")
+            mock_threading_Thread_p.assert_called_once_with(
+                target=mock_gui_manager.redirect_when_ready_loop,
+                args=(mock_redirect_stop_event_arg, mock_shutdown_event),
+                daemon=True
+            )
+            mock_threading_Thread_p.return_value.start.assert_called_once()
+        else:
+            self.fail("threading.Thread for redirect_when_ready_loop was not called.")
+        mock_app_logger.info.assert_any_call("Redirection loop initiated.")
 
-        # Assert server monitoring loop
-        mock_app_logger.info.assert_any_call("BACKGROUND THREAD: Now monitoring server process and shutdown event.")
+        mock_app_logger.info.assert_any_call("Now monitoring server process and shutdown event.")
         mock_server_process_obj.poll.assert_called()
         mock_shutdown_event.wait.assert_any_call(timeout=1)
 
-        # Assert cleanup
-        mock_app_logger.info.assert_any_call("BACKGROUND THREAD: Cleaning up...")
-        self.assertTrue(mock_redirect_stop_event_arg.is_set()) # Check redirect stop event was set
-        mock_server_manager.shutdown_server.assert_called_once() # Server shutdown in finally
+        mock_app_logger.info.assert_any_call("Cleaning up...")
+        self.assertTrue(mock_redirect_stop_event_arg.is_set())
+        mock_server_manager.shutdown_server.assert_called_once()
 
     @patch('comfy_launcher.__main__.time.sleep', return_value=None)
-    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=threading.Event))
-    def test_app_logic_thread_func_gui_timeout(self, mock_app_shutdown_event_p, # from @patch('...app_shutdown_event')
-                                               mock_time_sleep_p,            # from @patch('...time.sleep')
-                                               MockTrayManager_class_level_param): # From class decorator
-        """Test app_logic_thread_func when GUI fails to load."""
+    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=TestMainExecution.OriginalEventClass))
+    @patch('comfy_launcher.__main__.threading.Event')
+    def test_app_logic_thread_func_gui_timeout(self, mock_sut_event_constructor,
+                                               mock_global_app_shutdown_event,
+                                               mock_time_sleep,
+                                               MockTrayManager_class_level_param):
         mock_app_logger = MagicMock(spec=logging.Logger)
         mock_gui_manager = MagicMock(spec=GUIManager)
-        mock_server_manager = MagicMock(spec=ServerManager) # Not used much here
+        mock_server_manager = MagicMock(spec=ServerManager)
         mock_server_log_path = Path("/fake/logs/server.log")
-        mock_shutdown_event = mock_app_shutdown_event_p
+        mock_shutdown_event = mock_global_app_shutdown_event
 
-        mock_gui_manager.is_window_loaded = MagicMock(spec=threading.Event)
-        mock_gui_manager.is_window_loaded.wait.return_value = False # Simulate timeout
-        mock_gui_manager.webview_window = MagicMock() # So it can try to load_html
-        # mock_gui_manager._get_asset_content.return_value = "Critical Error HTML {MESSAGE}" # No longer needed here
-        mock_shutdown_event.is_set.return_value = False # Simulate not already shutting down
+        mock_event_publisher = MagicMock()
+        mock_gui_load_event_instance_for_timeout = MagicMock(spec=self.OriginalEventClass, name="MockGuiLoadEventForTimeout")
+        mock_gui_load_event_instance_for_timeout.wait.return_value = False
+        mock_sut_event_constructor.return_value = mock_gui_load_event_instance_for_timeout
 
-        app_logic_thread_func(mock_app_logger, mock_gui_manager, mock_server_manager,
-                              mock_server_log_path, mock_shutdown_event)
+        mock_gui_manager.webview_window = MagicMock()
+        mock_shutdown_event.is_set.return_value = False
+        with patch('comfy_launcher.__main__.event_publisher', mock_event_publisher):
+            app_logic_thread_func(mock_app_logger, mock_gui_manager, mock_server_manager,
+                                  mock_server_log_path, mock_shutdown_event)
 
-        mock_app_logger.error.assert_any_call("BACKGROUND THREAD: GUI window did not signal 'loaded' in time. Aborting app logic.")
-        # Assert that load_critical_error_page is called, not its internal _get_asset_content
-        mock_gui_manager.load_critical_error_page.assert_called_once_with("GUI did not load correctly. Check launcher logs.")
-        mock_server_manager.kill_process_on_port.assert_not_called() # Should not proceed this far
-        mock_shutdown_event.set.assert_called_once() # Should signal shutdown
+        mock_app_logger.error.assert_any_call("GUI window did not signal 'loaded' in time. Aborting app logic.")
+        
+        mock_event_publisher.publish.assert_any_call(
+            launcher_main_module.AppEventType.APPLICATION_CRITICAL_ERROR,
+            message="GUI did not load correctly. Check launcher logs."
+        )
+        mock_gui_manager.load_critical_error_page.assert_not_called()
+        mock_server_manager.kill_process_on_port.assert_not_called()
 
     @patch('comfy_launcher.__main__.time.sleep', return_value=None)
-    @patch('comfy_launcher.__main__.threading.Thread') # For redirect thread
-    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=threading.Event))
-    def test_app_logic_thread_func_server_start_fails(self, mock_app_shutdown_event_p, # from @patch('...app_shutdown_event')
-                                                      mock_threading_Thread_p,      # from @patch('...threading.Thread')
-                                                      mock_time_sleep_p,            # from @patch('...time.sleep')
-                                                      MockTrayManager_class_level_param): # From class decorator
-        """Test app_logic_thread_func when server fails to start."""
+    @patch('comfy_launcher.__main__.threading.Thread')
+    @patch('comfy_launcher.__main__.app_shutdown_event', new_callable=lambda: MagicMock(spec=TestMainExecution.OriginalEventClass))
+    @patch('comfy_launcher.__main__.threading.Event')
+    def test_app_logic_thread_func_server_start_fails(self, mock_sut_event_constructor,
+                                                      mock_global_app_shutdown_event,
+                                                      mock_sut_thread_constructor,
+                                                      mock_time_sleep,
+                                                      MockTrayManager_class_level_param):
         mock_app_logger = MagicMock(spec=logging.Logger)
         mock_gui_manager = MagicMock(spec=GUIManager)
         mock_server_manager = MagicMock(spec=ServerManager)
         mock_server_log_path = Path("/fake/logs/server.log")
-        mock_shutdown_event = mock_app_shutdown_event_p
+        mock_shutdown_event = mock_global_app_shutdown_event
+
+        mock_event_publisher = MagicMock()
+        mock_gui_load_event_instance_for_success = MagicMock(spec=self.OriginalEventClass, name="MockGuiLoadEventForSuccess")
+        mock_gui_load_event_instance_for_success.wait.return_value = True
+        mock_sut_event_constructor.return_value = mock_gui_load_event_instance_for_success
 
-        mock_gui_manager.is_window_loaded = MagicMock(spec=threading.Event)
-        mock_gui_manager.is_window_loaded.wait.return_value = True
-        mock_server_manager.start_server.return_value = None # Simulate server start failure
+        mock_server_manager.start_server.return_value = None
         mock_gui_manager.webview_window = MagicMock()
-        # mock_gui_manager._get_asset_content.return_value = "Error HTML {ERROR_MESSAGE}" # No longer needed here
-        mock_shutdown_event.is_set.return_value = False # Simulate not already shutting down
-        # Ensure initial waits don't cause early exit
+        mock_shutdown_event.is_set.return_value = False
+        
         initial_wait_return_values = [False, False, False]
         def temp_wait_side_effect(timeout):
             if initial_wait_return_values: return initial_wait_return_values.pop(0)
             return False
         mock_shutdown_event.wait.side_effect = temp_wait_side_effect
-
-        with patch('comfy_launcher.__main__.settings') as mock_main_settings:
+        
+        with patch('comfy_launcher.__main__.settings') as mock_main_settings, \
+             patch('comfy_launcher.__main__.event_publisher', mock_event_publisher):
             mock_main_settings.PORT = 8188
             app_logic_thread_func(mock_app_logger, mock_gui_manager, mock_server_manager,
                                   mock_server_log_path, mock_shutdown_event)
 
-        mock_app_logger.error.assert_any_call("BACKGROUND THREAD: Failed to start ComfyUI server process. Aborting app logic.")
-        mock_gui_manager.load_error_page.assert_called_once_with("Could not start the ComfyUI server. Please check the server.log file for details.")
-        mock_threading_Thread_p.assert_not_called() # Redirect loop should not start
-        mock_shutdown_event.set.assert_called_once() # Should signal shutdown
+        mock_app_logger.error.assert_any_call("Failed to start ComfyUI server process. Aborting app logic.")
+        
+        mock_event_publisher.publish.assert_any_call(
+            launcher_main_module.AppEventType.APPLICATION_CRITICAL_ERROR,
+            message="Could not start the ComfyUI server. Please check the server.log file for details."
+        )
+        mock_gui_manager.load_error_page.assert_not_called()
+        mock_sut_thread_constructor.assert_not_called()
+
+class TestMainEventHandlers(unittest.TestCase):
+
+    def setUp(self):
+        self.mock_logger = MagicMock(spec=logging.Logger)
+        self.logger_patcher = patch('comfy_launcher.__main__.launcher_logger', self.mock_logger)
+        self.logger_patcher.start()
+
+    def tearDown(self):
+        self.logger_patcher.stop()
+
+    @patch('comfy_launcher.__main__.app_shutdown_event')
+    def test_handle_main_thread_quit_request(self, mock_app_shutdown_event):
+        launcher_main_module._handle_main_thread_quit_request()
+        mock_app_shutdown_event.set.assert_called_once()
+        self.mock_logger.info.assert_any_call("MainThread Handler: APPLICATION_QUIT_REQUESTED received. Ensuring app_shutdown_event is set.")
+
+    @patch('comfy_launcher.__main__.app_shutdown_event')
+    @patch('comfy_launcher.__main__.gui_manager_instance')
+    def test_handle_critical_error(self, mock_gui_manager_instance, mock_app_shutdown_event):
+        test_message = "A critical error occurred!"
+        launcher_main_module._handle_critical_error(test_message)
+        
+        mock_gui_manager_instance.load_critical_error_page.assert_called_once_with(test_message)
+        mock_app_shutdown_event.set.assert_called_once()
+        self.mock_logger.critical.assert_any_call(f"MainThread Handler: APPLICATION_CRITICAL_ERROR: {test_message}")
+
+    def test_handle_app_logic_shutdown_complete(self):
+        with patch('comfy_launcher.__main__._app_logic_completed_event') as mock_event:
+            launcher_main_module._handle_app_logic_shutdown_complete()
+            mock_event.set.assert_called_once()
+        self.mock_logger.info.assert_any_call("MainThread Handler: APP_LOGIC_SHUTDOWN_COMPLETE received.")
+
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/tests/test_tray_manager.py b/tests/test_tray_manager.py
index f65c7b0..b781247 100644
--- a/tests/test_tray_manager.py
+++ b/tests/test_tray_manager.py
@@ -12,8 +12,9 @@ if str(project_root) not in sys.path:
 
 from comfy_launcher.tray_manager import TrayManager
 from comfy_launcher.gui_manager import GUIManager # For spec
-from pystray import Menu as TrayMenu, MenuItem as TrayMenuItem # For type checking menu items
+from pystray import Menu as TrayMenu, MenuItem as TrayMenuItem, Icon as TrayIcon # Import Icon as TrayIcon
 from PIL import Image # For mocking Image.open
+from comfy_launcher.event_system import AppEventType # For event testing - this import is present
 
 class TestTrayManager(unittest.TestCase):
 
@@ -51,59 +52,41 @@ class TestTrayManager(unittest.TestCase):
     def test_create_menu(self):
         menu = self.tray_manager._create_menu()
         self.assertIsInstance(menu, TrayMenu)
-        self.assertEqual(len(menu.items), 2)
-
-        self.assertIsInstance(menu.items[0], TrayMenuItem)
-        self.assertEqual(menu.items[0].text, "Show/Hide Window")
-        self.assertTrue(menu.items[0].enabled)
-        # To test the action, we'll execute it and check if the correct method on tray_manager is called.
-        # First, mock the target methods on the instance.
-        self.tray_manager._on_show_hide_window_selected = MagicMock(name="_on_show_hide_window_selected_mock")
-        self.tray_manager._on_quit_selected = MagicMock(name="_on_quit_selected_mock")
+        self.assertEqual(len(menu.items), 1) # Only "Quit Application" now
 
-        # Re-create the menu now that the methods on the instance are mocked
+        # Mock the method on the instance BEFORE creating the menu that will use it for the action test
+        self.tray_manager._on_quit_selected = MagicMock(name="_on_quit_selected_mock")
         menu_with_mocked_actions = self.tray_manager._create_menu()
-
-        # Execute the action stored in the first menu item
-        menu_with_mocked_actions.items[0]._action()
-        self.tray_manager._on_show_hide_window_selected.assert_called_once()
-
-        self.assertIsInstance(menu.items[1], TrayMenuItem)
-        self.assertEqual(menu.items[1].text, "Quit Application")
-        self.assertTrue(menu.items[1].enabled)
-        # Execute the action stored in the second menu item
-        menu_with_mocked_actions.items[1]._action()
+        # Test the "Quit Application" item (which is now items[0])
+        self.assertEqual(menu_with_mocked_actions.items[0].text, "Quit Application")
+        self.assertTrue(menu_with_mocked_actions.items[0].enabled)
+        # pystray.MenuItem.__call__ expects (icon, item)
+        mock_icon_for_action = MagicMock(spec=TrayIcon)
+        menu_with_mocked_actions.items[0](mock_icon_for_action) # Call with icon only
         self.tray_manager._on_quit_selected.assert_called_once()
 
-    def test_on_show_hide_window_selected_shows_hidden_window(self):
-        self.mock_gui_manager.webview_window = MagicMock()
-        # Simulate pywebview 4.0+ behavior where .hidden attribute exists
-        self.mock_gui_manager.webview_window.hidden = True 
-
-        self.tray_manager._on_show_hide_window_selected()
-
-        self.mock_gui_manager.webview_window.show.assert_called_once()
-        self.mock_gui_manager.webview_window.hide.assert_not_called()
-        self.mock_logger.info.assert_any_call("Tray: Showing window.")
-
-    def test_on_show_hide_window_selected_hides_visible_window(self):
-        self.mock_gui_manager.webview_window = MagicMock()
-        # Simulate pywebview 4.0+ behavior where .hidden attribute exists and is False
-        self.mock_gui_manager.webview_window.hidden = False
-
-        self.tray_manager._on_show_hide_window_selected()
-
-        self.mock_gui_manager.webview_window.hide.assert_called_once()
-        self.mock_gui_manager.webview_window.show.assert_not_called()
-        self.mock_logger.info.assert_any_call("Tray: Hiding window.")
-
     def test_on_quit_selected(self):
         self.tray_manager.icon = MagicMock() # Simulate icon exists
         self.tray_manager._on_quit_selected()
         self.mock_shutdown_event.set.assert_called_once()
         self.tray_manager.icon.stop.assert_called_once()
-        self.mock_logger.info.assert_any_call("Tray: Quit selected. Signaling application shutdown.")
+        self.mock_logger.info.assert_any_call("Tray: Quit selected. Setting global shutdown event and publishing APPLICATION_QUIT_REQUESTED event.")
 
+    @patch('comfy_launcher.tray_manager.event_publisher.publish')
+    def test_handle_application_quit_request_stops_icon_and_publishes_complete(self, mock_event_publish):
+        self.tray_manager.icon = MagicMock(spec=TrayIcon)
+        
+        # Simulate the event being handled
+        self.tray_manager.handle_application_quit_request()
+
+        self.tray_manager.icon.stop.assert_called_once()
+        # The TRAY_MANAGER_SHUTDOWN_COMPLETE event is published by the run() method when the thread ends, not this handler.
+        self.mock_logger.info.assert_any_call("Handler: APPLICATION_QUIT_REQUESTED received by TrayManager. Stopping tray icon.")
+
+    def test_handle_gui_window_hidden_updates_menu(self):
+        self.tray_manager.icon = MagicMock(spec=TrayIcon)
+        self.tray_manager.handle_gui_window_hidden()
+        self.tray_manager.icon.update_menu.assert_called_once()
 
     @patch('comfy_launcher.tray_manager.TrayIcon')
     @patch('comfy_launcher.tray_manager.Image.open')
@@ -126,7 +109,7 @@ class TestTrayManager(unittest.TestCase):
             self.app_name, mock_image_instance, self.app_name, "fake_menu"
         )
         mock_tray_icon_instance.run.assert_called_once()
-        self.mock_logger.info.assert_any_call("TrayManager: Starting tray icon event loop...")
+        self.mock_logger.info.assert_any_call("Starting tray icon event loop...")
 
     @patch('comfy_launcher.tray_manager.TrayIcon')
     @patch('comfy_launcher.tray_manager.Image.new') # Mock Image.new for fallback
@@ -156,9 +139,9 @@ class TestTrayManager(unittest.TestCase):
         mock_pystray_icon_class.side_effect = Exception("Pystray critical error")
         self.mock_shutdown_event.is_set.return_value = False # Ensure event is not already set
         self.tray_manager.run()
-        self.mock_logger.error.assert_any_call("TrayManager: Failed to run tray icon: Pystray critical error", exc_info=True)
+        self.mock_logger.error.assert_any_call("Failed to run tray icon: Pystray critical error", exc_info=True)
         self.mock_shutdown_event.set.assert_called_once()
-
+        self.mock_logger.info.assert_any_call("Signaling app shutdown due to critical tray error.")
     @patch('comfy_launcher.tray_manager.threading.Thread')
     def test_start_creates_and_starts_thread(self, mock_thread_class):
         mock_thread_instance = MagicMock()
@@ -169,7 +152,7 @@ class TestTrayManager(unittest.TestCase):
         mock_thread_class.assert_called_once_with(target=self.tray_manager.run, daemon=True, name="TrayIconThread")
         mock_thread_instance.start.assert_called_once()
         self.assertEqual(self.tray_manager._thread, mock_thread_instance)
-        self.mock_logger.info.assert_any_call("TrayManager: Thread started.")
+        self.mock_logger.info.assert_any_call("Thread started.")
 
     @patch('comfy_launcher.tray_manager.threading.Thread')
     def test_start_does_not_restart_alive_thread(self, mock_thread_class):
@@ -193,14 +176,14 @@ class TestTrayManager(unittest.TestCase):
 
         mock_icon_instance.stop.assert_called_once()
         mock_thread_instance.join.assert_called_once_with(timeout=2)
-        self.mock_logger.info.assert_any_call("TrayManager: Tray icon stopped.")
+        self.mock_logger.info.assert_any_call("Tray icon stopped.")
 
     def test_stop_no_icon_or_thread(self):
         self.tray_manager.icon = None
         self.tray_manager._thread = None
         self.tray_manager.stop() # Should not raise errors
-        self.mock_logger.info.assert_any_call("TrayManager: Stopping tray icon...")
-        self.mock_logger.info.assert_any_call("TrayManager: Tray icon stopped.")
+        self.mock_logger.info.assert_any_call("Stopping tray icon...")
+        self.mock_logger.info.assert_any_call("Tray icon stopped.")
 
 if __name__ == '__main__':
     unittest.main()
\ No newline at end of file
